<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title>Hackerrank test solution part 1</title>
      <url>/tutorial/2021/03/27/hackerrank-solusion-part-1/</url>
      <content type="text">Simple Array Sum

tujuannya adalah untuk mendapatkan jumlah dari tiap elemen array, contohnya 1 + 2 + 4 + 10 + 11 = 31

Input
6
1 2 3 4 10 11

Output
31


Code

  var sum = 0;
    for (var i = 0; i &amp;lt;ar.length; i++) {
    sum += ar[i];
    }
    return sum;

Alternative

  let sum = (accumulator, currentValue) =&amp;gt; accumulator + currentValue;
  return ar.reduce(sum);


Compare the Triplets
di compare the triplets ini bertujuan untuk menentukan nilai mana yang lebih besar dari tiap elemen array, contohnya kasus nya :
jika a mempunyai array [1,2,3] dan b mempunyai array [3,2,1] dengan kondisi di bawah ini

  jika a[0] lebih besar dari pada b[0] maka a mendapatkan poin 1
  jika a[1] sama dengan b[1]maka tidak ada yang mendapatkan poin
  jika a[2] lebih kecil dari b[2] maka b yang mendapatkan poin


kemudian hasil poin antara a dan menggabungkan ke dalam array menjadi [1,1]

Input
17 28 30
99 16 8


Output
2 1


Code
    let score = [0,0]

    for (let i = 0; i &amp;lt; a.length; i++)
        a[i] &amp;gt; b[i] ? score[0]++ : a[i] &amp;lt; b[i] ? score[1]++ : &quot;&quot;
    return score


A Very Big Sum
tujuannya adalah untuk mendapatkan jumlah dari tiap elemen array, contohnya 1 + 2 + 4 + 10 + 11 = 31

Input
6
1 2 3 4 10 11

Output
31


Code
    let score = [0,0]

    for (let i = 0; i &amp;lt; a.length; i++)
        a[i] &amp;gt; b[i] ? score[0]++ : a[i] &amp;lt; b[i] ? score[1]++ : &quot;&quot;
    return score


Alternative
  let sum = (accumulator, currentValue) =&amp;gt; accumulator + currentValue;
  return ar.reduce(sum);


Diagonal Difference

Input
3
11 2 4
4 5 6
10 8 -12


Output
15


Explanation

The primary diagonal is:
11
   5
     -12


Sum across the primary diagonal: 11 + 5 - 12 = 4
The secondary diagonal is:
     4
   5
10


Code

    var n = matrix.length;
    var diag1 = 0;
    var diag2 = 0;
    for(var i=0; i&amp;lt;n; i++){
        for(var j=0; j&amp;lt;n; j++){
            // an element from the main diagonal
            if(i === j) { 
                diag1 += matrix[i][j];
            }
            // an element from the counterdiagonal
            if(i + j === n - 1){
                diag2 += matrix[i][j];
            }
        }
    }
    return Math.abs(diag1 - diag2);

Plus Minus

Input
STDIN           Function
-----           --------
6               arr[] size n = 6
-4 3 -9 0 4 1   arr = [-4, 3, -9, 0, 4, 1]


Output
0.500000
0.333333
0.166667


Code
 let positives = 0, negatives = 0, zeros = 0;
     const len = arr.length || 0;
      
     if (len &amp;gt; 0 &amp;amp;&amp;amp; len &amp;lt;= 100) {
          arr.map((elem, key) =&amp;gt; {
               if (elem &amp;gt; 0) {
                    positives++;
               } else if (elem &amp;lt; 0) {
                    negatives++; 
               } else {
                    zeros++;
               }
                  
               return elem; 
          }); 
     } 
     
     console.log((positives / len) || 0);
     console.log((negatives / len) || 0);
     console.log((zeros / len) || 0);  


Alternative
    let positive = arr.filter(number =&amp;gt; number &amp;gt; 0).length / arr.length;
    let negative = arr.filter(number =&amp;gt; number &amp;lt; 0).length / arr.length;;
    let zeronums = arr.filter(number =&amp;gt; number == 0).length / arr.length;;
    return console.log(positive.toFixed(6) + '\n' + negative.toFixed(6) + '\n' + zeronums.toFixed(6))


Staircase

Input
6


Output
     #
    ##
   ###
  ####
 #####
######


Code


    // want to declare a variable that will hold the final output that we will print 
    let output = ''
    
    // outer for loop to keep track of the overall number of rows (n)
    for (let i = 1; i &amp;lt;= n; i++) {
    
        // inner for loop to keep track of the preceding spaces on each line
            // s should start out at n-1 which we can see from the pic I drew
            // s should be greater than or equal to i because the number of spaces decreases as i increases
            // decrease s bc the number of spaces decreases as i increases
        for (let s = n - 1; s &amp;gt;= i; s--) {
            output += ' '
        }
        
        // inner for loop to keep track of the #s on each line
            // h should start at one because the first line will always have one #
            // h should be less than or equal to the row that we are on since h will approach and eventually equal n
            // h increases since we increment h to equal i which will eventually equal n
        for (let h = 1; h &amp;lt;= i; h++) {
            output += '#'
        }
        // new line
        output += &quot;\n&quot;
       
    }
    // log the final result
    console.log(output)


Alternative
// here we use just one for loop where i tracks the number of rows
  // the number of rows (i) should be less than or equal to n
    for (let i = 1; i &amp;lt;= n; i++) {
      // print out a &quot; &quot; n-i times and append a # i times
      // console log adds a new line by default
      
        console.log(&quot; &quot;.repeat(n-i) + &quot;#&quot;.repeat(i))
    }    


Birthday Cake Candles

Input
4
3 2 1 3

Output
2


Explanation

Candle heights are [3,2,1,3] . The tallest candles are 3 units, and there are 2 of them.

Code

// Step 1
    let max = 0;
    let counter = 0;

    // Step 2 (a)
    arr.forEach(item =&amp;gt; {
        // Step 3
        if (item &amp;gt; max) {
            // Step 4
            max = item;
            counter = 1;
            // Step 2 (b)
        } else if (item === max) {
            counter++;
        }
    });

    return counter;


Alternative

    let maxNum = Math.max(...ar);
    let filtered = ar.filter(function(value, index, arr) {
        return value === maxNum;
    });
    return filtered.length;


Time Conversion

Input

Output

Code

const arr = s.slice(0,8).split(':');
arr[0] = (s.indexOf('PM') &amp;gt; -1) ?
         (arr[0] == 12 ? '12' : Number(arr[0]) + 12) :
         (arr[0] == 12 ? '00' : arr[0]);
return arr.join(':');


Grading Students

Input

Outputs

Code

    let output = [];
    for (let i = 0; i &amp;lt; grades.length; i++) {
        if (grades[i] &amp;gt;= 38) {
            let reminder = grades[i] % 5;
            if (reminder === 3) {
                output.push(grades[i] + 2)
            } else if (reminder === 4) {
                output.push(grades[i] + 1)
            } else {
                output.push(grades[i]);
            }
        } else {
            output.push(grades[i]);
        }
    }

    return output;


Mini-Max Sum

Input

Output

Code
  let minValue = 0, maxValue = 0, minIndex = 0, maxIndex = 0, minSum = 0, maxSum = 0;
  minValue = Math.min(...arr);
  maxValue = Math.max(...arr);
  minIndex = arr.indexOf(minValue);
  maxIndex = arr.indexOf(maxValue);

  for (let i = 0; i &amp;lt; arr.length; i++){
      if (minIndex != i) {
          maxSum += arr[i];
      }
      if (maxIndex != i) {
          minSum += arr[i];
      }
  }
     console.log(minSum, maxSum);


Alternative

    let maxVal = Math.max(...arr);
    let minVal = Math.min(...arr);
    console.log((sum - maxVal) + ' ' + (sum - minVal));


Apple and Orange

Input

Output

Code

const fLoc = function (treeLoc, arr2d) {
       return arr2d.map(fruitLoc =&amp;gt; (treeLoc + fruitLoc));
    }
    const fRange = function (s, t, arr2d) {
        let a, b;
        a = 0; b = 0;
        arr2d.forEach((f, i) =&amp;gt; {
            if (i === 0) { // apple count
                f.forEach(loc =&amp;gt; s &amp;lt;= loc &amp;amp;&amp;amp; loc &amp;lt;= t ? a++ : null);
            }
            if (i === 1) { // orange count
                f.forEach(loc =&amp;gt; s &amp;lt;= loc &amp;amp;&amp;amp; loc &amp;lt;= t ? b++ : null);
            }
        });
        return [a, b];
    }
    console.log(fRange(s, t, [fLoc(a, apples), fLoc(b, oranges)]).join('\n'));


Alternative

// using filter
function countApplesAndOranges2(s, t, a, b, apples, oranges) {
  console.log(apples.filter(d =&amp;gt; s - a &amp;lt;= d &amp;amp;&amp;amp; d &amp;lt;= t - a).length);
  console.log(oranges.filter(d =&amp;gt; s - b &amp;lt;= d &amp;amp;&amp;amp; d &amp;lt;= t - b).length);
}




// using reduce
function countApplesAndOranges3(s, t, a, b, apples, oranges) {
  console.log( apple.reduce((sum, d) =&amp;gt; sum + (s - a &amp;lt;= d &amp;amp;&amp;amp; d &amp;lt;= t - a), 0));
  console.log(orange.reduce((sum, d) =&amp;gt; sum + (s - b &amp;lt;= d &amp;amp;&amp;amp; d &amp;lt;= t - b), 0));
}


// using filter and map
function countApplesAndOranges4 {
  function addBy(num) {
    return (d) =&amp;gt; d + num;
  }
  function isScored(d) {
    return s &amp;lt;= d &amp;amp;&amp;amp; d &amp;lt;= t;
  }
  const larry = apples.map(addBy(a)).filter(isScored).length;
  const rob = oranges.map(addBy(b)).filter(isScored).length;
  console.log(larry, rob);
}


// using Array.prototype (bad because a new version of ECMA could come out with a 'sum' helper for arrays)
function countApplesAndOranges5 {
  Array.prototype.sum = function(f) {
      return this.reduce((s, v) =&amp;gt; s + f(v), 0);
  }
  console.log( apple.sum(d =&amp;gt; s - a &amp;lt;= d &amp;amp;&amp;amp; d &amp;lt;= t - a));
  console.log(orange.sum(d =&amp;gt; s - b &amp;lt;= d &amp;amp;&amp;amp; d &amp;lt;= t - b));
}


Number Line Jumps

Input

Output

Code

    let result = 'NO'
    for (let i = 0; i &amp;lt;= 10000; i++) {
        if (x1 + v1 * i === x2 + v2 * i) {
            result = 'YES'
        }
    }
    return result;

</content>
      <categories>
        
          <category> tutorial </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Back to Basic Javascript</title>
      <url>/tutorial/2020/01/12/back-basic-js/</url>
      <content type="text">Hai, it’s really embarrasing because i was did interview and going to fuck up. Because i not understand about javascript, backend and etc. anything about what i really strong about javascript, just destroy everything my expectation. i’m dissapointed my friend because my friend is know my ability. So here i am, come back to write again because i dont want to forget anymore. thanks to my office because i can work from anywhere hahah

Types
as you know, there are types in javascript is primitive and complex
primitve

  When you access a primitive type you work directly on its value.


primitive
string
number
boolean
null
undefined
symbol
bigint
complex

  When you access a complex type you work on a reference to its value.


complex have
complex
object
array
function

</content>
      <categories>
        
          <category> tutorial </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Belajar Javascript Part 1</title>
      <url>/2018/11/06/belajar-javascript-part-1/</url>
      <content type="text">#Function Executions
Kebanyakan pembuatan app menggunakan Javascript dibangun dengan V8, yaitu runtime yang dimiliki oleh chrome. untuk pemahaman lebih lanjut dapat ditonton video yang dijelaskan oleh Philip Robert,
What the heck is the event loop anyway?
Call Stack

  It’s a data structure which records the function calls, basically where in the program we are. If we call a function to execute , we push something on to the stack, and when we return from a function, we pop off the top of the stack.


sebelum memulai call stack memahami terlebih dahulu tentang Execution Context.
Execution Context

Call Stack merupakan pemanggilan fungsi - fungsi menggunakan konsep Stack. Stack merupakan sturktur data dimana data dipanggil dengan Last In First Out(LIFO) ketika fungsi pada javascript paling belakang, maka akan tercetak

Heap

  Objects are allocated in a heap i.e mostly unstructured region of memory. All the memory allocation to variables and objects happens here.


Queue

  A JavaScript runtime contains a message queue, which is a list of messages to be processed and the associated callback functions to execute. When the stack has enough capacity, a message is taken out of the queue and processed which consists of calling the associated function (and thus creating an initial stack frame). The message processing ends when the stack becomes empty again. In basic words , these messages are queued in response to external async events(such as a mouse being clicked or receiving the response to an HTTP request), given a callback function has been provided. If, for example a user were to click a button and no callback function was provided — no message would have been enqueued.


Event Loop

Monkey Patch
A monkey patch is a way for a program to extend or modify supporting system software locally (affecting only the running instance of the program).
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Belajar Nest JS Part 2</title>
      <url>/2018/11/02/belajar-nest-js-part-2/</url>
      <content type="text">
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Belajar Nest JS Part 1</title>
      <url>/2018/11/01/belajar-nest-js-part-1/</url>
      <content type="text">
  Nest is a framework for building efficient, scalable Node.js server-side applications. It uses progressive JavaScript, is built with TypeScript (preserves compatibility with pure JavaScript) and combines elements of OOP (Object Oriented Programming), FP (Functional Programming), and FRP (Functional Reactive Programming).
Under the hood, Nest makes use of Express, but also provides compatibility with a wide range of other libraries (e.g. Fastify). This allows for easy use of the myriad third-party plugins which are available.


Untuk melakukan instalasi, saya menggunakan git

git clone https://github.com/nestjs/typescript-starter.git project
cd project
npm install
npm run start


or

npm i -g @nestjs/cli
nest new nest-restaurant-api
npm run start:dev


setelah di clone, otomatis membuat template dari Nets JS. kemudian setelah run di terminal dapat membuka di browser localhost:3000 maka muncul output seperti gambar di bawah ini

kemudian untuk menghubungkan database MongoDB dengan mongoose, buat folder database di dalam folder src

src
  database
    database.module.ts
    database.providers.ts


setelah buka file database.module.ts dan isikan kode dibawah ini

import * as mongoose from 'mongoose';
import { DB_PROVIDER } from '../constants';

export const databaseProviders = [
    {
        provide: DB_PROVIDER,
        useFactory: async () =&amp;gt; {
            (mongoose as any).Promise = global.Promise;
            return await mongoose.connect('mongodb://localhost:27017/parley');
        },
    },
];


pada {DB_PROVIDER} module yang dipanggil tidak ada, buat file constants.ts

export const DB_PROVIDER = 'DbConnectionToken';


setelah berhasil menghubungkan MongoDB dengan Nest JS, install MongoDB dengan perintah
npm i --save mongoose
npm i --save-dev


setelah itu untuk mengakses alamat MongoDB yaitu mongodb://localhost:27017/parley dan otomatis membuat database dengan nama parley.

Kemudian definisikan database ke modul di dalam file database.module.ts

import { Module } from '@nestjs/common';
import { databaseProviders } from './database.providers';

@Module({
    components: [...databaseProviders],
    exports: [...databaseProviders],
})
export class DatabaseModule { };


setelah itu baru kita bisa menarik database modul di dalam modul2 lain dan menggunakan mongoose untuk menghubungkan objek untuk dijalankan query nya di database.

Post module
Kemudian mendesain app nya pendekatan dari entitas berbasis modular. Untuk membuat direktori modul pertama di dalam  direktori src.

src
  -posts
    --dto
      ---create-post.dto.ts
    --interfaces
      --post.interface.ts
    --posts.controller.ts
    --posts.module.ts
    --posts.providers.ts
    --posts.schema.ts
    --posts.service.ts


pada dto kita mendefinisikan struktur data untuk API endpoint. Ketika membuat

export class CreatePostDto {
    readonly title: string;
    readonly content: string;
    readonly userId: string;
}


kemudian kita membuat post interface di posts.interface.ts

import { Document } from 'mongoose';

export interface Post extends Document {
    readonly title: string;
    readonly content: string;
    readonly userId: string;
}

ketika sudah membuat 2 file diatas sekarang membuat post service pada posts.service.ts. Untuk postService membuat komponen kelas konstruktor , untuk menginjeksi dimana Nest JS melakukan depedency injection.

import { Model } from 'mongoose';
import { Component, Inject } from '@nestjs/common';

import { Post } from './interfaces/post.interface';
import { CreatePostDto } from './dto/create-post.dto';
import { POST_MODEL_PROVIDER } from '../constants';

@Component()
export class PostsService {
    constructor(
        @Inject(POST_MODEL_PROVIDER) private readonly postModel: Model&amp;lt;Post&amp;gt;) { }

    async create(createPostDto: CreatePostDto): Promise&amp;lt;Post&amp;gt; {
        const createdPost = new this.postModel(createPostDto);
        return await createdPost.save();
    }

    async findAll(): Promise&amp;lt;Post[]&amp;gt; {
        return await this.postModel.find().exec();
    }
}


Di dalam provider, membangun mongoose model dan injeksi model. Untuk membuat model, kita harus mendefiniskan skema pada file posts.schema.ts

import * as mongoose from 'mongoose';

export const PostSchema = new mongoose.Schema({
    title: {
        type: String,
        required: true,
    },
    content: {
        type: String,
        required: false,
    },
    userId: {
        type: mongoose.SchemaTypes.ObjectId,
        required: true,
    }
});

Kegunaan pada file src
app.controller.ts and app.service.ts: those files are responsible for generating the message Hello world when the endpoint / is accessed through the browser. Because this endpoint is not important to this application you may delete these files as well. Soon you are going to learn in more details what controllers and services are.
app.module.ts: this is a class of the type module that is responsible for declaring imports, exports, controllers, and providers to a Nest.js application. Every application has at least one module but you may create more than one module for more complex applications (more details on Nest.js documentation). The application of this tutorial will have only one module.
main.ts: this is the file responsible for starting the server.
main.hrm.ts: is a Hot Module Replacement file that installs modules during the server execution and it is useful to speed up the development process.

Penjelasan REST API

  RESTful API / REST API merupakan implementasi dari API (Application Programming Interface). REST (Representional State Transfer) adalah suatu arsitektur metode komunikasi yang menggunakan protokol HTTP untuk pertukaran data dan metode ini sering diterapkan dalam pengembangan aplikasi. Dimana tujuannya adalah untuk menjadikan sistem yang memiliki performa yang baik, cepat dan mudah untuk di kembangkan (scale) terutama dalam pertukaran dan komunikasi data




URL Design
RESTful API diakses menggunakan protokol HTTP. Penamaan dan struktur URL yang konsisten akan menghasilkan API yang baik dan mudah untuk dimengerti developer. URL API biasa disebut endpoint dalam pemanggilannya. Contoh penamaan URL / endpoint yang baik adalah seperti berikut :

/users
/users/1234
/users/1234/photos
/users/1234/photos/abc
HTTP Verbs
Setiap request yang dilakukan terdapat metode yang dipakai agar server mengerti apa yang sedang di request client, diantaranya yang umum dipakai adalah :

GET
GET adalah metode HTTP Request yang paling simpel, metode ini digunakan untuk membaca atau mendapatkan data dari sumber.
Contoh :
GET /users : Mengembalikan daftar user
GET /users/1234 : Mengembalikan data user dengan ID 1234

POST
POST adalah metode HTTP Request yang digunakan untuk membuat data baru dengan menyisipkan data dalam body saat request dilakukan.
Contoh :
POST /users : Membuat data user baru

PUT
PUT adalah metode HTTP Request yang biasanya digunakan untuk melakukan update data resource.
Contoh :
PUT /users/1234 : Mengupdate data user dengan ID 1234

DELETE
DELETE adalah metode HTTP Request yang digunakan untuk menghapus suatu data pada resource.
Contoh :
DELETE /users/1234 : Menghapus data user dengan ID 1234

Selain HTTP Verbs diatas, masih ada metode HEAD dan PATCH dalam HTTP Request, tetapi jarang sekali digunakan.

HTTP Response Code
HTTP response code adalah kode standarisasi dalam menginformasikan hasil request kepada client. Secara umum terdapat 3 kelompok yang biasa kita jumpai pada RESTful API yaitu :

2XX : adalah response code yang menampilkan bahwa request berhasil.
4XX : adalah response code yang menampilkan bahwa request mengalami kesalahan pada sisi client.
5XX : adalah response code yang menampilkan bahwa request mengalami kesalahan pada sisi server.

Dan berikut ini adalah response code yang biasa digunakan pada REST :

200 OK
Response code ini menandakan bahwa request yang dilakukan berhasil.

201 Created
Response code ini menandakan bahwa request yang dilakukan berhasil dan data telah dibuat. Kode ini digunakan untuk mengkonfirmasi berhasilnya request PUT atau POST.

400 Bad Request
Response code ini menandakan bahwa request yang dibuat salah atau data yang dikirim tidak ada.

401 Unauthorized
Response code ini menandakan bahwa request yang dibuat membutuhkan authentication sebelum mengakses resource.

404 Not Found
Response Code ini menandakan bahwa resource yang di dipanggil tidak ditemukan.

405 Method Not Allowed
Response code ini menandakan bahwa request endpoint ada tetapi metode HTTP yang digunakan tidak diizinkan.

409 Conflict
Response code ini menandakan bahwa request yang dibuat terdapat duplikasi, biasanya informasi yang dikirim sudah ada sebelumnya.

500 Internal Server Error
Response code ini menandakan bahwa request yang dilakukan terdapat kesalahan pada sisi server atau resource.

Format Response
Setiap request yang dilakukan client akan menerima data response dari server, response tersebut biasanya berupa data XML ataupun JSON. Setelah mendapatkan data response tersebut barulah client bisa menggunakannya dengan cara memparsing data tersebut dan diolah sesuai kebutuhan.
Contoh :
XML

HTTP/1.1 200 OK
Date: Sat, 06 Oct 2001 23:20:04 GMT
Server: Apache.1.3.12 (Unix)
Connection: close
Content-Type: text/xml
Content-Length: 124





18.24668429131
&amp;lt;/param&amp;gt;


JSON

GET /users/1234

HTTP/1.1 200 OK
Content-Type: application/vnd.api+json

{
“id”: “1234”,
“first_name”: “jhon”,
“last_name”: “doe”,
“created”: “2015-05-22T14:56:29.000Z”,
“updated”: “2015-05-22T14:56:29.000Z”
}
Penjelasan Tentang Mongoose
Mongoose adalah sebuah Object Document Mapper (ODM). Ini berarti Mongoose mengizinkan Anda untuk mendefinisikan obyek dengan skema yang benar-benar diketik yang dipetakan ke sebuah dokumen MongoDB.

Mongoose menyediakan jumlah fungsionalitas yang luar biasa yang berkaitan dengan pembuatan dan pengerjaan skema. Mongoose saat ini memiliki delapan tipe skema dimana propertinya disimpan seperti saat berada di MongoDB. Diantaranya:

String
Number
Date
Buffer
Boolean
Mixed
ObjectId
Array
Setiap tipe data memungkinkan Anda untuk menentukan:

sebuah nilai default
sebuah fungsi validasi custom
menunjukan field yang dibutuhkan
fungsi get yang memungkinkan Anda untuk memanipulasi data sebelum dikembalikan sebagai obyek
sebuah set fungsi yang memungkinkan Anda untuk memanipulasi data sebelum disimpan ke database
membuat indeks yang memungkinkan data agar ditarik secara lebih cepat
Selanjutnya untuk opsi umum ini, tipe data tertentu memungkinkan Anda untuk menyesuaikan lebih lanjut bagaimana data disimpan dan diambil dari database. Sebagai contoh, sebuah tipe data String juga memungkinkan Anda untuk menentukan pilihan tambahan sebagai berikut:

mengubah menjadi huruf kecil
mengubah menjadi huruf besar
memangkas data sebelum disimpan
regular-expression yang dapat membatasi data yang diizinkan untuk disimpan selama dalam proses validasi
sebuah enum yang dapat menentukan daftar string yang valid
Properti Number dan Date keduanya mendukung penentuan nilai minimal dan maksimal yang diizinkan untuk field tersebut.

Sebagian besar dari delapan jenis data yang diizinkan seharusnya cukup familiar untuk Anda. Namun, ada beberapa pengecualian yang mungkin menjadi pengecualian bagi Anda, seperti Buffer, Mixed, ObjectId, dan Array.

Tipe data Buffer memungkinkan Anda untuk menyipan data biner. Contoh yang umum untuk data biner seperti gambar atau file encodem seperti dokumen PDF.

Tipe data Mixed mengubah properti menjadi field “dapat menjadi apa saja”. Field ini menyerupai berapa banyak pengembang yang menggunakan MongoDB karena tidak ada struktur yang jelas. Berhati-hatilah menggunakan tipe data ini karena tipe ini kehilangan banyak fitur hebat yang disediakan oleh Mongoose, seperti validasi data dan pendeteksi perubahan entitas untuk dapat mengetahui secara otomatis dalam memperbarui properti saat menyimpan.

Tipe data ObjectId umumnya menentukan sebuah tautan ke dokumen yang lain di dalam database Anda. Sebagai contoh, jika anda memiliki sebuah koleksi buku dan penulis, dokumen buku kemungkinan berisi sebuah properti ObjectId yang menunjuk ke penulis tertentu dari dokumen.

Tipe data Array memungkinkan anda untuk menyimpan array yang seperti JavaScript. Dengan sebuah tipe data Array, anda dapat melakukan operasi array Javascript yang umum, seperti push, pop, shift, slice, dll.
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Part 1 Belajar Ios</title>
      <url>/2018/10/11/part-1-belajar-iOS/</url>
      <content type="text">
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Belajar Android dengan Firebase Part 1</title>
      <url>/2018/10/05/part-1-firebase-android-findingbpjs/</url>
      <content type="text">Firebase

Membuat Model untuk informasi dari user dan untuk menyimpan data ke dalam tabel firebase

Membuat
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Sentiment Analysis with Python 3</title>
      <url>/2018/07/15/part-1-pengenalan-neural-network/</url>
      <content type="text">Artificial Intelligence

Sebelum mengenal
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Pertemuan 2 Mata Kuliah Pengantar Komputasi Modern</title>
      <url>/tugas%20kuliah/2018/04/28/pertemuan-2-pengantar-komputasi-modern/</url>
      <content type="text">Map Reduce
MapReduce merupakan model pemrograman untuk memproses data berukuran besar secara terdistribusi dan paralel dalam cluster yang terdiri atas ribuan komputer

Map
Proses Map yaitu mengumpulkan informasi dari potongan - potongan data dari komputer - komputer yang saling terhubung.

Reduce
Hasil dari proses Map di arakhkan ke proses Reduce yaitu mengirimkan hasil akhr kepada pengguna.

produk

  Apache Hadoop
  Pig
  Cascading
  Microsoft Dryad
  IBM MapReduce Tool for   Eclipse  
  Skynet
  CouchDB


NoSQL
NoSQL adalah sebuah konsep mengenai penyimpanan data non-relasional. NoSQL sangat berguna pada data-data yang terus-menerus berkembang, dimana  data tersebut sangat kompleks sehingga sebuah database relational tidak lagi bisa mengakomodir


  Kelebihan NoSQL


NoSQL bisa menampung data yang terstruktur, semi terstruktur dan tidak terstuktur secara efesien dalam skala besar.
Menggunakan OOP dalam pengaksesan atau manipulasi datanya.
jika database noSQL di jalankan di cluster server (multiple server) maka data akan tersebar secara otomatis dan merata keseluruh server


  Kekurangan NoSQL


Hostingnya mahal. beberapa layanan di luar negeri mencharge biaya 100-200USD untuk hosting database noSQL
Sulitnya mencari hosting Cpanel yang mendukung database MongoDB atau database noSQL lainnya

CouchDB
CouchDB yang dikembangkan oleh Apache lebih dulu muncul jauh sebelum mongoDB yaitu pada tahun 2005. CouchDB tidak menyimpan datanya dalam tabel melainkan dalam dokumen seperti halnya mongoDB.
Basis data ini juga merupakan proyek open source serta dikembangkan dalam bahasa pemrograman Erlang oleh karena itu kita bisa ikut berkontribusi dalam pengembangan CouchDB agar basis data ini lebih baik.



Cassandra
Cassandra merupakan sebuah sistem penyimpanan data terdistribusi untuk menangani jumlah data yang sangat besar dan terstruktur. Cassandra juga dikembangkan Apache.

Cassandra juga merupakan aplikasi open source yang ditulis dalam bahasa Java dengan lisensi Apache License 2.0.

Untuk memproses datanya, Cassandra menggunakan bahasa sendiri yang mirip dengan SQL yaitu Cassandra Query Language (CQL).



MongoDB

MongoDB merupakan basis data yang paling populer diantara basis data NoSQL lainnya. Hal ini dikarenakan pemasangan maupun penggunaan mongoDB tidaklah sulit atau merepotkan penggunanya. Selain itu mongoDB juga merupakan salah satu basis data yang open source.
MongoDB merupakan basis data NoSQL yang document based. Ia menyimpan data-datanya dalam suatu dokumen JSON yang disebut BSON (Binary JSON).
Dikembangkan sejak tahun 2009, mongoDB sekarang telah mendukung hampir semua bahasa pemrograman untuk dapat berinteraksi dengan mongoDB.



Riak
Riak merupakan basis data NoSQL terdistribusi yang menyimpan datanya dalam bentu key-value. Riak menawarkan fitur high availability, fault tolerance, operational simplicaity, dan scalability.

Riak memiliki dua versi yakni Open source edition dan Enterprise edition. Enterprise edition menawarkan dukungan berbayar intensif dari pengembangnya. Pengguna Open source edition dapat bermigrasi kapan saja ke Enterprise edition jika dibutuhkan. Erlang ditulis dalam bahasa pemrograman Erlang dengan lisensi Apache License 2.0



Redis
Redis merupakan basis data berbasis key-value. Redis merupakan singkatan dari REmote DIctionary Server. Basis data ini dikembangkan oleh Salvatore Sanfilippo pada tahun 2009 dan ditulis dalam bahasa C. Redis banyak dipilih karena memiliki fitur in-memory, networked, dan durabilitas tinggi.

Redis mendukung banyak bahasa pemrograman seperti ActionScript, C/C++, C#, Clojure, Common LIsp, Dart, Erlang, Go, Haskell, Haxe, Io, Java, JavaScript (Node.js), Lua, Objective-C, Perl, PHP, Pure Data, Python, R, Ruby, Scala, Smalltalk, dan Tcl.



Quantum Computation

Quantum computation atau komputasi quantum merupakan sebuah perhitungan yang menggunakan kuantum mekanika fenomena yang dilakukan untuk melakukan operasi data

Entaglement
Entanglement adalah suatu teori mekanika quantum yang menggambarkan seberapa cepat dan betapa kuatnya keterhubungan partikel-partikel pada Quantum computer yang dimana jika suatu partikel diperlakukan “A” maka akan memberikan dampak “A” juga ke partikel lainnya

Quantum Gates
Quantum gates merupakan gerbang dari kuantum yang berfungsi mengoperasikan bit yang terdiri dari 0 dan 1 juga dalam qubits sehingga proses yang terjadi lebih cepat, karena setiap perhitungan dilakukan secara bersamaan



Pengoperasian Data Qubit
Dalam komputer kuantum, sejumlah partikel elemental seperti elektron atau foton dapat digunakan yang  bertindak sebagai representasi dari 0 dan  1. Setiap partikel-partikel ini dikenal sebagai qubit, sifat dan perilaku partikel-partikel ini membentuk dasar dari komputasi kuantum.
Namun dalam mekanika quantum, objek apapun yang memiliki dua status berbeda pasti memiliki rangkaian status potensial, disebut superposisi, yang menjerat kedua status hingga derajat bermacam-macam.


Algoritma Shor

Inti dari algoritma ini merupakan bagaimana cara menyelesaikan faktorisasi terhaadap bilanga interger atau bulat yang besar.

Algoritma Shor terdiri dari dua bagian:

  Penurunan yang bisa dilakukan pada komputer klasik, dari masalah anjak untuk masalah ketertiban - temuan.
  Sebuah algoritma kuantum untuk memecahkan masalah order-temuan

</content>
      <categories>
        
          <category> tugas kuliah </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Pertemuan 1 Mata Kuliah Pengantar Komputasi Modern</title>
      <url>/2018/04/09/pertemuan-1-Pengantar-Komputasi-Modern/</url>
      <content type="text">Teori Komputasi

Pengertian Teori Komputasi
Teori komputasi adalah cabang ilmu komputer teoritis, berkaitan dengan studi bagaimana persoalan(problem) dapat diselesaikan pada sebuah model dengan menggunakan algoritma. Model tersebut dinamakan model komputasi.

Teori Otomata
Teori Otomata adalah teori mengenai mesin-mesin abstrak, dan berkaitan erat dengan teori bahasa formal. ada beberapa hal yang berkaitan dengan Otomata, yaitu Grammar. Grammar adalah bentuk abstrak yang dapat diterima (accept) untuk membangkitkan suatu kalimat otomata berdasarkan suatu aturan tertentu.

Teori Komputabilitas

Teori komputabilitas bertujuan untuk memeriksa apakah persoalan komputasi dapat dipecahkan pada suatu model komputasi teoritis. Dengan kata lain, teori komputabilitas mengklasifikasikan persoalan sebagai dapat dipecahkan (solvable) atau persoalan yang tidak dapat dipecahkan (unsolvable).

Teori Kompleksitas
Teori kompleksitas bertujuan untuk mengkaji kebutuhan waktu dan ruang untuk memecahkan persoalan yang diselesaikan dengan pendekatan yang berbeda-beda.

Model komputasi

Finite State Automata(FSA) / Finite State Machine(FSM)
Finite State Machine dapat berupa suatu mesin yang tidak memiliki output. Finite State Machine yang tidak mengeluarkan output ini dikenal sebagai Finite State Automata (FSA).

Secara formal FSA dapat didefinisikan sebagai TUPLE-5 : (K, VT, M, S, Z)
Dimana :
K	: himpunan hingga stata,
VT 	: himpunan hingga simbol input (alfabet)
M 	: fungsi transisi, menggambarkan transisi stata AH akibat pembacaan symbol input. (Fungsi transisi ini biasanya diberikan dalam bentuk tabel.)
S  	: stata awal
Z  	: himpunan stata penerima

Ada dua jenis Finite State Automata :
• Deterministic Finite Automata : transisi stata AH akibat pembacaan sebuah simbol
bersifat tertentu. “Jika pada setiap state dari FSA tersebut apabila menerima input
sebuah simbol maka HANYA ada SATU NEXT STATE yang mungkin dituju.”
M(DFA) : K x VT x K

• Non Deterministik Finite Automata : transisi stata AH akibat pembacaan sebuah simbol
bersifat tak tentu. “Jika FSA tersebut menerima input simbol maka minimal ada satu
state yang akan berpindah ke LEBIH DARI SATU NEXT STATE yang mungkin dituju.”
M(AHN) : K x VT x 2K

Contoh Soal

Push Down Automata(PDA)
PDA adalah mesin otomata yang memiliki kendali masukan menggunakan teknik LIFO (Last In First Out), untuk menentukan apakah suatu output diterima atau tidak oleh mesin tsb. Dalam melakukan proses peneerimaan input, PDA menggunakan memory stack.
Mekanisme kerja memory stack adalah menyimpan input pertama pada alamat paling bawah, input berikutnya di simpan pada alamat di atasnya, dan input terakhir di simpan pada alamat paling atas. Perintah operasi yang digunakan untuk menyimpan input pada stack adalah “push”. Sedangkan perintah operasi untuk mengeluarkan input yang telah tersimpan adalah “pop”.

Sebuah PDA dinyatakan dengan 7 Tupel:
Q = himpunan state
Σ = himpunan simbol input
T = simbol stack
Δ = fungsi transisi
S = state awal
F = state akhir
Z = top of stack

Turing Machine

Mesin Turing adalah model komputasi teoretis yang ditemukan oleh Alan Turing, berfungsi sebagai model ideal untuk melakukan perhitungan matematis. Walaupun model ideal ini diperkenalkan sebelum komputer nyata dibangun, model ini tetap diterima kalangan ilmu komputer sebagai model komputer yang sesuai untuk menentukan apakah suatu fungsi dapat selesaikan oleh komputer atau tidak (menentukan computable function). Mesin Turing terkenal dengan ungkapan “ Apapun yang bisa dilakukan oleh Mesin Turing pasti bisa dilakukan oleh komputer.”



Implementasi

Bidang Fisika
Implementasi komputasi modern di bidang Fisika adalah Computational Physics yang mempelajari suatu gabungan antara Fisika, Komputer Sains dan Matematika Terapan untuk memberikan solusi pada “Kejadian dan masalah yang kompleks pada dunia nyata” baik dengan menggunakan simulasi juga penggunaan Algoritma yang tepat.
Banyak perangkat lunak ataupun bahasa yang digunakan, seperti : MatLab, Visual Basic, Fortran, Open Source Physics (OSP), Labview, Mathematica, dan lain sebagainya digunakan untuk pemahaman dan pencarian solusi numerik dari masalah-masalah pada Fisika komputasi.
Bidang Kimia
Implementasi komputasi modern di bidang Kimia adalah Computational Chemistry yaitu penggunaan ilmu komputer untuk membantu menyelesaikan masalah Kimia. Contohnya penggunaan super komputer untuk menghitung struktur dan sifat molekul. Istilah Kimia teori dapat didefinisikan sebagai deskripsi Matematika untuk Kimia, sedangkan Kimia komputasi biasanya digunakan ketika metode Matematika dikembangkan dengan cukup baik untuk dapat digunakan dalam program komputer.
Bidang Matematika
Menyelesaikan sebuah masalah yang berkaitan dengan perhitungan Matematis, namun dalam pengertian yang akan dibahas dalam pembahasan komputasi modern ini merupakan sebuah sistem yang akan menyelesaikan masalah Matematis menggunakan komputer dengan cara menyusun Algoritma yang dapat dimengerti oleh komputer.
Bidang Geografi
Komputasi dalam bidang Geografi biasanya di gunakan untuk peramalan cuaca, di Indonesia khususnya ada salah satu instansi Negara dengan nama BMKG (Badan Meteorologi Klimatologi dan Geofisika) yakni instansi negara yang meneliti mengamati tentang Metereologi, Klimatologi kualitas udara dan Geofisika
Bidang Geologi
Implementasi pada bidang ini untuk memetakan letak sumber daya dan kontur dari permukaan bumi yang terdapat hasil tambang.

Cloud Computing
Cloud Computing hadir dengan memudahkan akses data dari mana saja dan kapan saja, karena dengan memanfaatkan internet dan menggunakan perangkat fixed atau mobile device menggunakan internet cloud sebagai tempat penyimpanan data, aplikasi dan lainya

Grid Computing

Komputasi Grid sebenarnya merupakan sebuah aplikasi pengembangan dari jaringan komputer (network). Hanya saja, tidak seperti jaringan komputer konvensional yang berfokus pada komunikasi antar piranti (device), aplikasi pada grid computing dirancang untuk memanfaatkan sumber daya pada terminal dalam jaringannya.

Virtualisasi
Virtualisasi adalah sebuah teknologi, yang memungkinkan anda untuk membuat versi virtual dari sesuatu yang bersifat fisik, misalnya sistem operasi, storage data atau sumber daya jaringan. Proses tersebut dilakukan oleh sebuah software atau firmware bernama Hypervisor. Hypervisor inilah yang menjadi nyawanya virtualisasi, karena dialah layer yang “berpura – pura” menjadi sebuah infrastruktur untuk menjalankan beberapa virtual machine.

Istilah virtualisasi perangkat-keras mengacu kepada upaya menciptakan mesin virtual yang bekerja layaknya sebuah komputer lengkap dengan sistem operasi.

Para-virtualisasi: Perangkat keras tidak disimulasikan tetapi perangkat-lunak tamu berjalan dalam domainnya sendiri seolah-olah dalam sistem yang berbeda. Dalam hal ini perangkat-lunak tamu perlu disesuaikan untuk dapat berjalan.

Virtualisasi sebagian: Tidak semua aspek lingkungan disimulasikan tidak semua perangkat-lunak dapat langsung berjalan, beberapa perlu disesuaikan untuk dapat berjalan dalam lingkungan virtual ini.

Virtualisasi penuh: Hampir menyerupai mesin asli dan mampu menjalankan perangkat lunak tanpa perlu diubah.

Distributed Computation dalam Cloud Computing

Komputasi Terdistribusi merupakan salah satu tujuan dari Cloud Computing, karena menawarkan pengaksesan sumber daya secara parallel, para pengguna juga bisa memanfaatkannya secara bersamaan (tidak harus menunggu dalam antrian untuk mendapatkan pelayanan), terdiri dari banyak sistem sehingga jika salah satu sistem crash, sistem lain tidak akan terpengaruh, dapat menghemat biaya operasional karena tidak membutuhkan sumber daya (resourches).

Standar Teknologi Informasi pada Cloud Computing


SaaS (Software as a Service)
Software as a Service adalah layanan software yang digunakan melalui internet. Sebenarnya hal ini bukan merupakan hal yang asing dan sering kita gunakan (hanya mungkin kita belum tahu aja), contoh dari SaaS ini adalah google docs, facebook, aplikasi CRM berbayar, dan lain-lain. Pengguna hanya perlu menggunakan aplikasi tersebut tanpa harus mengerti bagaimana data disimpan, bagaimana aplikasi tersebut di maintenance, karena hal tersebut merupakan service yang disediakan penyedia jasa. Pembayaran dari penggunaan aplikasi-aplikasi ini pun hanya per pemakaiannya (terkadang ada yang tak berbayar tetapi ada fitur-fitur tertentu yang bisa didapatkan ketika pengguna membayar fitur-fitur tersebut, yah semacam nyewa parabola gitu lah, bayar berdasar channel yang diinginkan).

PaaS (Platform as a Service)
Platform as a Service adalah penyediaan platform bagi developer yang disediakan melalui internet. Hal ini dibutuhkan ketika aplikasi yang disediakan melalui SaaS tidak sesuai dengan kebutuhan proses bisnis yang terdapat pada perusahaan. PaaS memungkinkan kita untuk membangun aplikasi, mengupload aplikasi, melakukan testing aplikasi, ataupun mengatur konfigurasi yang dibutuhkan dalam proses pengembangan aplikasi.

IaaS (Infrastructure as a Service)
Infrastructure as a Service adalah penyediaan infrastruktur yang disediakan melalui internet dan dibayarkan berdasarkan pemakaian. Hal ini terjadi apabila developer membutuhkan sebuah infrastruktur dimana dia dapat melakukan setting untuk jalannya sebuah aplikasi. IaaS memberikan kendali penuh bagi pengguna layanan untuk menyewa infrastruktur IT (storage, RAM, prosesor dll) secara virtual tanpa sistem operasi, yang tentunya pemilihan sistem operasi tersebut dipilih berdasarkan keinginan pengguna.  Apabila SaaS dan PaaS kurang terasa manfaatnya bagi perusahaan, IaaS ini sangat menguntungkan bagi perusahaan kecil yang membutuhkan sebuah infrastruktur IT tanpa harus membeli perangkat yang dibutuhkan tersebut.
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Rangkuman Sistem Multimedia</title>
      <url>/tugas%20kuliah/2018/03/21/rangkuman-sistem-multimedia/</url>
      <content type="text">Multimedia  : Adalah beberapa media yang berbeda untuk menggabungkan dan menyampaikan informasi dalam bentuk Text , Audio , Grafik , Animasi dan Video atau bisa juga di katakan kombinasi antara tiga elemen yaitu suara, gambar dan text.

Sistem  : Adalah kumpulan dari elemen – elemen yang berinteraksi untuk mencapai suatu tujuan tertentu.

Sistem Multimedia : Adalah beberapa sistem yang mendukung lebih dari satu macam   media.
Text

jenis text terbagi dalam 3 kategori

Plain text
Plain text adalah teks yang dikode dalam format ASCII

Contoh :



Hyper Text
Hypert Text adalah teks yang memiliki fasilitas linking dan betujuan untuk menyambungkan/berhubungan dengan dokumen lain/teks sebelumnya yang telah diberi atau memiliki format pada sisi penulisannya. Hypert Text disebut juga sebagai link penghubung.
 Hypertext terbagi menjadi dua,yaitu  :


  
    HTML (Hypertext Markup Language) yang berfungsi untuk mengontrol tampilan web
  
  
    XML (Extensible Markup Language) yang berfungsi untuk menjadikan dokumen lebih simple dan lebih cepat.
  


Rich text
Rich Text Format adalah teks yang sudah diformatting dan sudah di desain sedemikian rupa sehingga pada teks ini kita dapat memberikan efek pada teks dengan di Bold, Italic, Underline dan diberi warna.


Image
Image atau citra adalah gambar pada bidang dua dimensi
Sebuah titik terkecil dalam sebuah gambar grafis yang dihitung per inci disebut dengan pixel.


Video
Video
Merupakan rangkaian gambar yang ditampilkan secara sekuensial

Representasi dan Kompresi Data

Kompresi Data merupakan cara untuk memperkeil kebutuhan penyimpanan data

Kompresi terbagi 2 jenis yaitu Lossy dan Loseless


  
    Lossy : teknik kompresi dengan menghilangkan beberapa informasi penting
  
  
    Loseless : teknik kompresi dengan tidak menghilangkan beberapa informasi
  


Representasi dan Kompresi pada Data Teks

Run Length Encoding
Suatu teknik kompresi dengan menghasilkan output Loseless

Contoh :

Data: ABCCCCCCCCDEFGGGG = 17 karakter

dapat menggunakan tanda ! untuk mengurangi panjang nya data sehingga menjadi seperti ini

Data: ABCCCCCCCCDEFGGGG = 17 karakter

Huffman Coding
Huffman merupakan teknik dengan banyak nya 1 huruf kemudian dibagi banyak nya huruf maka dilakukan Kompresi

Contoh :

MAMA SAYA
A = 4 -&amp;gt; 4/8 = 0.5
M = 2 -&amp;gt; 2/8 = 0.25
S = 1 -&amp;gt; 1/8 = 0.125
Y = 1 -&amp;gt; 1/8 = 0.125
Total = 8 karakter

kemudian dibuat pohon Huffman nya maka menjadi seperti ini


Representasi dan Kompresi pada Data Suara

Kompresi pada Audio yaitu dengan memotong jarak amplitudo paling maksimum dan minimum yang dianggap noise

Contoh Lossy format :Vorbis, MP3

Contoh Loseless format : FLAC

Jaringan Multimedia
Penggunaan komputer untuk menampilkan media dengan interaksi dan komunikasi

Streaming Multimedia

Merupakan multimedia yang secara terus menerus diterima dan ditampilkan oleh user

Voice Over Internet protocol

teknologi yang memungkinkan komunikasi suara menggunkana jaringan berbasis IP

Session Internet Protocol
SIP merupakan sebuah protocol standart multimedia dimana merupakan produk dari Internet Engineering Task Force (IETF) dan telah digunakan menjadi suatu standart penggunaan VoIP

Real Time Transport

Real Time Transport Protocol  (RTP) didefinisikan sebagai standarisasi paket untukmengirimkan audio dan video pada jaringan IP.

Distribusi multimedia

B. Broadcasting penyiaran multimedia baik berupa video maupun suara yang disiarkan kepada penonton melalui media elektronik. Ex: Live instagram


Cara kerja tv:
    • Kamera merekam sebuah objek yang dengan sistem prism dibagi menjadi tiga warna
    • CCD mengubahnya menjadi sebuah elektronik signal yang disebut video signal
    • Tranmisi merubahnya menjadi signal televisi yang disiarkan melalui antenna dengan gelombang elektromagnetik
    • Anttena rumah akan menerima signal televisi
    • Tunner memisahkan video signal dengan audio signak
    • Video signal dibagi menjadi tiga signal
    • Ketiga signal akan menampilkan gambar

Cara kerja live broadcasting:
bekerja di saat yang bersamaan secara langsung, dimana audio mengirim datanya ke sound card dan dienkripsi oleh encoder yang akan langsung diupload ke streaming server oleh streamer.
EX:

C. Internet Radio Yaitu: audio digital yang ditransmisikan melalui internet. Cara kerja internet radio:
1. Audio pada sebuah sound card diencoding pada komputer yang digunakan untuk broadcasting
2. Sistem encode menterjemahkan audio ke streaming format dan mengkompresnya untuk bisa dikirimkan via internet.
3. Audio yang telah dikompres dikirim ke server
4. Server mengirimkan data audio melalui internet ke komputer pendengar melalui sebuah plug-in atau software.
5. Plug-in akan menterjemhkan data audio dari server ke suara yang bisa didengar pendengar   EX: Prambors









D. Video on Demand (VoD) sistem televisi interaktif yang memfasilitasi untuk memilih sendiri program televisi atau video yang ingin ditonton.


Augmented Reality

sebuah konsep yang memadukan dunia maya(virtual) dan dunia nyata dengan cara menanamkan sebuah object di dalam proses pembuatannya.

Jenis - jenis

  
    Memakai Marker (Marker Based Tracking), yaitu terdapat proses pemakaian marker didalamnya untuk memunculkan objek 2D atau 3D.
  
  
    Tanpa Marker (Markerless), yaitu tidak terdapat pemakaian marker didalamnya tetapi menggunakan teknik yang mempunyai ruang lingkup lebih luas daripada metode Marker Based Tracking.
  


Digital Culture

suatu perkembangan yang menjadikan budaya di era digital contoh nya seperti mengakses informasi dari internet, serta mengirimkan email dan download upload

contoh : E-commerce, E-book dll
</content>
      <categories>
        
          <category> tugas kuliah </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Sentiment Analysis with Python 3</title>
      <url>/tutorial/2018/03/19/sentiment-analysis/</url>
      <content type="text">Team


  Abdul Ghoni Abbasi (5C414919)
  Aldi Ginanjar (50414741)
  M. Fadlan Prayoga (56414918)
  Widya Maylani (5C414218)


Scraping

  Web Scraping adalah pengambilan sebuah dokumen semi-struktur dari internet, umumnya berupa halaman-halaman web dalam bahasa markup seperti HTML atau XHTML, dan menganalisis untuk diambil data tertentu dari halaman tersebut




import requests

graph_api_version = 'v2.9'
# paste your access token below
access_token = 'EAAanvSwEfswBAG4xDMDJuJqmsPb179nvHy0XPMR7BcgPejGKBhaa7Iy0EaQu2W5PCOA92BcgiZA9nXJCJrFZBzKksVGwMCQHX7oq7lAXsn4YZBObZAZCI9kKa04m0eMsOpNoeZAwveKaZBu2cKQDUfycIM8zjbor0tbSplAABUlwQZDZD'

user_id = '164305410295882'


post_id = '1727321057327635'


url = 'https://graph.facebook.com/{}/{}_{}/comments'.format(graph_api_version, user_id, post_id)

comments = []

r = requests.get(url, params={'access_token': access_token})
while True:
    data = r.json()
    if 'error' in data:
        raise Exception(data['error']['message'])
    for comment in data['data']:
        text = comment['message'].replace('\n', ' ')
        comments.append(text)
    print('got {} comments'.format(len(data['data'])))
    if 'paging' in data and 'next' in data['paging']:
        r = requests.get(data['paging']['next'])
    else:
        break

#menyimpan komentar ke dalam suatu file
with open('comments.txt', 'w', encoding='utf-8') as f:
    for comment in comments:
        f.write(comment + '\n')


import library requests agar mendapatkan akses token dari facebook, kemudian memasukkan access token yang terdapat pada facebook. Berikutnya untuk mengambil semua data komentar pada suatu post facebook yang dibutuhkan adalah id dari user facebook dan id dari post  yang ditentukan dalam variabel url nya. Setelah itu bisa di ketahui konsep scraping untuk mengambil semua komentar di dalam suatu post tersebut membuat array dengan nama comments and menggunakan library requests untuk mendapatkan akses token, untuk dibuat scraping atau data komentar dari suatu post dibuat kondisi terdapat error dalam data JSON tersebut maka ditampilkan pesan error, jika tidak maka dimuat isi array dengan banyak nya komentar menggunakan perintah

for comment in data['data']:
  text = comment['message'].replace('\n', ' ')
  comments.append(text)

Jika sudah simpan file python dengan nama scraping.py lalu run program yang sudah dibuat dengan perintah python3 scraping.py maka akan ditampilkan output


Kemudian untuk data comment yang sudah di extract disimpan dalam file bernama comments.txt dan output yang dhasilkan dari script python diatas berupa:



Sentiment Analysis

Sebelum melakukan sentimen analisis, import library seperti NLTK, pandas

import nltk
import pandas as pd
import string


Library yang digunakan yaitu vader lexicon untuk pemanggilan fungsi SentimentIntensityAnalyzer()
from nltk.sentiment.vader import SentimentIntensityAnalyzer
sid = SentimentIntensityAnalyzer()

Print Positive, Negative and Neutral

summary = {&quot;positive&quot;:0,&quot;neutral&quot;:0,&quot;negative&quot;:0}
for x in messages:
    ss = sid.polarity_scores(x)
    if ss[&quot;compound&quot;] == 0.0:
        summary[&quot;neutral&quot;] +=1
    elif ss[&quot;compound&quot;] &amp;gt; 0.0:
        summary[&quot;positive&quot;] +=1
    else:
        summary[&quot;negative&quot;] +=1
print(summary)


untuk penentuan suatu komentar termasuk komentar positif dibuat kondisi jika nilai variabel ss yang merupakan perhitungan pada library SentimentIntensityAnalyzer() sama dengan 0 maa akan masuk ke dalam indeks “neutral” akan bertambah 1, untuk nilai lebih dari sama dengan maka akan masuk ke dalam indeks “positive” dan untuk nilai komentar yang negatif jika nilai nya kurang dari 0 maka indeks array “negative” akan bertambah. Untuk mencetak perolehan angka sentimen gunakan perintah print(summary)


{'positive': 57, 'neutral': 81, 'negative': 55}


Result from Pie Chart

**python**
import matplotlib.pyplot as plt
pie_plot = pd.Series(summary,name='')
pie_plot.plot.pie(fontsize=11,figsize=(6,6),autopct='%.2f');


Kemudian untuk memvisualisasikan data sentimen nya,gunakan library matplotlib dan dipanggil perintah untuk menyajikan data chart dengan jenis pie sehingga data yang ditampilkan dengan menampilkan dictionary summary dan menampilkan angka persentasi 2 angka dibelakang koma dengan perintah autopct=%2.f maka outputnya adalah

</content>
      <categories>
        
          <category> tutorial </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
