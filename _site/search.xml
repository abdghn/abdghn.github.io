<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title>REST API dengan GO</title>
      <url>/tutorial/2019/12/25/membuat-REST-API-dengan-go/</url>
      <content type="text">REST API

Membuat Program Go
Berikut ini adalah program Go

package main

import (
    &quot;log&quot;
    &quot;net/http&quot;
)

type server struct{}

func (s *server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    w.Write([]byte(`{&quot;message&quot;: &quot;hello world&quot;}`))
}

func main() {
    s := &amp;amp;server{}
    http.Handle(&quot;/&quot;, s)
    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))
}


lalu untuk run program nya menggunakan

go run main.go


{&quot;message&quot;: &quot;hello world&quot;}


Berikut nya untuk menunjukkan menggunakan ServeHTTP

package main

import (
    &quot;log&quot;
    &quot;net/http&quot;
)

func home(w http.ResponseWriter, r *http.Request) {
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    switch r.Method {
    case &quot;GET&quot;:
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{&quot;message&quot;: &quot;get called&quot;}`))
    case &quot;POST&quot;:
        w.WriteHeader(http.StatusCreated)
        w.Write([]byte(`{&quot;message&quot;: &quot;post called&quot;}`))
    case &quot;PUT&quot;:
        w.WriteHeader(http.StatusAccepted)
        w.Write([]byte(`{&quot;message&quot;: &quot;put called&quot;}`))
    case &quot;DELETE&quot;:
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{&quot;message&quot;: &quot;delete called&quot;}`))
    default:
        w.WriteHeader(http.StatusNotFound)
        w.Write([]byte(`{&quot;message&quot;: &quot;not found&quot;}`))
    }
}

func main() {
    http.HandleFunc(&quot;/&quot;, home)
    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))
}


Gorilla Mux
Dalam menggunakan gorilla mux dengan menggunakan perintah

 go get github.com/gorilla/mux


setelah menambahkan mod gorilla mux, kode program nya seperti ini

package main

import (
    &quot;log&quot;
    &quot;net/http&quot;

    &quot;github.com/gorilla/mux&quot;
)

func home(w http.ResponseWriter, r *http.Request) {
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    switch r.Method {
    case &quot;GET&quot;:
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{&quot;message&quot;: &quot;get called&quot;}`))
    case &quot;POST&quot;:
        w.WriteHeader(http.StatusCreated)
        w.Write([]byte(`{&quot;message&quot;: &quot;post called&quot;}`))
    case &quot;PUT&quot;:
        w.WriteHeader(http.StatusAccepted)
        w.Write([]byte(`{&quot;message&quot;: &quot;put called&quot;}`))
    case &quot;DELETE&quot;:
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{&quot;message&quot;: &quot;delete called&quot;}`))
    default:
        w.WriteHeader(http.StatusNotFound)
        w.Write([]byte(`{&quot;message&quot;: &quot;not found&quot;}`))
    }
}

func main() {
    r := mux.NewRouter()
    r.HandleFunc(&quot;/&quot;, home)
    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, r))
}


Handle HTTP methods
Dalam menggunakan Handlefunc untuk membuat fungsi di handle oleh HTTP method

package main

import (
    &quot;log&quot;
    &quot;net/http&quot;

    &quot;github.com/gorilla/mux&quot;
)

func get(w http.ResponseWriter, r *http.Request) {
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    w.WriteHeader(http.StatusOK)
    w.Write([]byte(`{&quot;message&quot;: &quot;get called&quot;}`))
}

func post(w http.ResponseWriter, r *http.Request) {
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    w.WriteHeader(http.StatusCreated)
    w.Write([]byte(`{&quot;message&quot;: &quot;post called&quot;}`))
}

func put(w http.ResponseWriter, r *http.Request) {
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    w.WriteHeader(http.StatusAccepted)
    w.Write([]byte(`{&quot;message&quot;: &quot;put called&quot;}`))
}

func delete(w http.ResponseWriter, r *http.Request) {
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    w.WriteHeader(http.StatusOK)
    w.Write([]byte(`{&quot;message&quot;: &quot;delete called&quot;}`))
}

func notFound(w http.ResponseWriter, r *http.Request) {
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    w.WriteHeader(http.StatusNotFound)
    w.Write([]byte(`{&quot;message&quot;: &quot;not found&quot;}`))
}

func main() {
    r := mux.NewRouter()
    r.HandleFunc(&quot;/&quot;, get).Methods(http.MethodGet)
    r.HandleFunc(&quot;/&quot;, post).Methods(http.MethodPost)
    r.HandleFunc(&quot;/&quot;, put).Methods(http.MethodPut)
    r.HandleFunc(&quot;/&quot;, delete).Methods(http.MethodDelete)
    r.HandleFunc(&quot;/&quot;, notFound)
    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, r))
}


Sub Router

func main() {
    r := mux.NewRouter()
    api := r.PathPrefix(&quot;/api/v1&quot;).Subrouter()
    api.HandleFunc(&quot;&quot;, get).Methods(http.MethodGet)
    api.HandleFunc(&quot;&quot;, post).Methods(http.MethodPost)
    api.HandleFunc(&quot;&quot;, put).Methods(http.MethodPut)
    api.HandleFunc(&quot;&quot;, delete).Methods(http.MethodDelete)
    api.HandleFunc(&quot;&quot;, notFound)
    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, r))
}


Kemudian menambahkan prefix dengan contoh api/v1 jika ingin membuat v2 nanti nya

package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;strconv&quot;

    &quot;github.com/gorilla/mux&quot;
)

func get(w http.ResponseWriter, r *http.Request) {
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    w.WriteHeader(http.StatusOK)
    w.Write([]byte(`{&quot;message&quot;: &quot;get called&quot;}`))
}

func post(w http.ResponseWriter, r *http.Request) {
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    w.WriteHeader(http.StatusCreated)
    w.Write([]byte(`{&quot;message&quot;: &quot;post called&quot;}`))
}

func put(w http.ResponseWriter, r *http.Request) {
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    w.WriteHeader(http.StatusAccepted)
    w.Write([]byte(`{&quot;message&quot;: &quot;put called&quot;}`))
}

func delete(w http.ResponseWriter, r *http.Request) {
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    w.WriteHeader(http.StatusOK)
    w.Write([]byte(`{&quot;message&quot;: &quot;delete called&quot;}`))
}

func params(w http.ResponseWriter, r *http.Request) {
    pathParams := mux.Vars(r)
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)

    userID := -1
    var err error
    if val, ok := pathParams[&quot;userID&quot;]; ok {
        userID, err = strconv.Atoi(val)
        if err != nil {
            w.WriteHeader(http.StatusInternalServerError)
            w.Write([]byte(`{&quot;message&quot;: &quot;need a number&quot;}`))
            return
        }
    }

    commentID := -1
    if val, ok := pathParams[&quot;commentID&quot;]; ok {
        commentID, err = strconv.Atoi(val)
        if err != nil {
            w.WriteHeader(http.StatusInternalServerError)
            w.Write([]byte(`{&quot;message&quot;: &quot;need a number&quot;}`))
            return
        }
    }

    query := r.URL.Query()
    location := query.Get(&quot;location&quot;)

    w.Write([]byte(fmt.Sprintf(`{&quot;userID&quot;: %d, &quot;commentID&quot;: %d, &quot;location&quot;: &quot;%s&quot; }`, userID, commentID, location)))
}

func main() {
    r := mux.NewRouter()

    api := r.PathPrefix(&quot;/api/v1&quot;).Subrouter()
    api.HandleFunc(&quot;&quot;, get).Methods(http.MethodGet)
    api.HandleFunc(&quot;&quot;, post).Methods(http.MethodPost)
    api.HandleFunc(&quot;&quot;, put).Methods(http.MethodPut)
    api.HandleFunc(&quot;&quot;, delete).Methods(http.MethodDelete)

    api.HandleFunc(&quot;/user/{userID}/comment/{commentID}&quot;, params).Methods(http.MethodGet)

    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, r))
}

</content>
      <categories>
        
          <category> tutorial </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Belajar Go Part 1</title>
      <url>/tutorial/2019/11/19/belajar-go-part-1/</url>
      <content type="text">Penjelasan Golang
Golang atau Go merupakan bahasa pemrograman yang di publikasikan tahun 2009 oleh Google dan Bahasa Go mengambil struktur sintaks seperti C / C++.


Kelebihan Golang

  Mendukung konkurensi di level bahasa dengan pengaplikasian cukup mudah
  Mendukung pemrosesan data dengan banyak prosesor dalam waktu yang bersamaan (pararel processing)
  Memiliki garbage collector
  Proses kompilasi sangat cepat
  Bukan bahasa pemrograman yang hirarkial, menjadikan developer tidak perlu ribet memikirkan segmen OOP-nya
  Package/modul yang disediakan terbilang lengkap. Karena bahasa ini open source, banyak sekali developer yang juga mengembangkan modul-modul lain yang bisa dimanfaatkan


Hello World!

Instalasi Go

Konfigurasi Go

Membuat Aplikasi Go
package main

import &quot;fmt&quot;
func main () {
    fmt.Println(&quot;Hello World&quot;) 
}


atau bisa juga

package main

func main () {
    print(&quot;Hello World&quot;) 
}


Kemudian untuk menjalankan aplikasi nya  dengan tahapan awal yaitu compile

go build main.go


Kemudian untuk menjalankan aplikasi dengan perintah

./main

Jika ingin melakukan perbaikan bugs atau error tidak perlu menggunakan compile, bisa dengan perintah

go run main.go


import f &quot;fmt&quot;

func main(){
    f.Println(&quot;Hello World&quot;)
}

Variabel
Untuk mendekralasi variabel pada Go dapat menggunakan tipe data atau tidak. Perbedaannya hanya di bagian penulisan nya saja.

Variabel dengan tipe data
Deklarasi dengan tipe data atau yang biasa disebut manifest typing pada Go memiliki standar yaitu menggunakan keyword var dan menggunakan jenis tipe data nya apa. contohnya bisa dilihat di bawha ini.
package main

import &quot;fmt&quot;

func main() {
    var firstName string = &quot;john&quot;

    var lastName string
    lastName = &quot;wick&quot;

    fmt.Printf(&quot;halo %s %s!\n&quot;, firstName, lastName)
}



Variabel tanpa tipe data
Deklarasi tanpa tipe data atau yang biasa disebut interfence pada Go untuk mendeklarasikan variabel

var firstName string = &quot;john&quot;
lastName := &quot;wick&quot;

fmt.Printf(&quot;halo %s %s!\n&quot;, firstName, lastName)

</content>
      <categories>
        
          <category> tutorial </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Belajar Uni Testing Javascript</title>
      <url>/tutorial/2019/11/02/belajar-unit-testing-javascript-part-1/</url>
      <content type="text">Teori

  Unit Testing is a level of software testing where individual units/ components of a software are tested


Penjelasan dari teori unit testing yaitu untuk menguji apakah fungsi yang kita buat telah sesuai dengan desain sistem.

Kalau diibaratkan dalam kegiatan nyata misalkan kita ingin memasak tentunya hal pertama yang dilakukan adalah menyiapkan baik itu peralatan atau bahan memasak. Dalam membuat suatu masakan, hal - hal yang harus diperhatikan adalah seperti berapa lama dalam mengaduk bahan - bahan yang telah dicampurkan, menentukan suhu pada kompor atau oven, atau takaran untuk menaruh bumbu masak. Dalam unit testing, langkah - langkah untuk melakukan adalah  :

  Menentukan nilai dari parameter input
  Memanggil unit yang dites melewatkannya dengan parameter input
  Menerima parameter kembalian dari unit yang dites dan mencetaknya, menampilkannya, atau mengetes hasilnya terhadap hasil yang diharapkan


Keuntungan yang didapat dengan melakukan dengan unit testing adalah

  Mencari error atau bug yang disebabkan oleh perubahan code menjadi lebih mudah
  Code menjadi lebih reusable
  Waktu yang dibutuhkan untuk melakukan debug lebih sedikit karena tidak perlu melakukan “developer test” dimana kita menjalankan program kita sambil menyediakan beberapa input untuk menguji apakah program akan berjalan sesuai keinginan kita.


Pada javascript, unit testing yang digunakan adalah Mocha JS dan Chai.

npm install mocha chai


Kemudian fungsi untuk development

module.exports = function(){
    return 'hello'
}


Lalu untuk membuat fungsi unit testing untuk menguji fungsi yang mengembalikan nilai string ‘hello’. berikut ini adalah fungsi uit testing nya

const assert = require('chai').assert
const app = require('../app')


describe('App', function(){ 
    it('should return hello', function(){
        assert.equal(app(), 'hello')
    })
})


Dari describe yaitu untuk mengambil dari export controller App
</content>
      <categories>
        
          <category> tutorial </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>How to be UI / UX Designer</title>
      <url>/tutorial/2019/03/25/belajar-ui-ux/</url>
      <content type="text">
</content>
      <categories>
        
          <category> tutorial </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>How To Be Front End</title>
      <url>/tutorial/2019/03/22/how-to-be-front-end/</url>
      <content type="text">Komponen Dasar

Mengenal HTML

Semantic HTML
Link :

  https://www.duniailkom.com/tutorial-belajar-html5-pengertian-semantic-tag-pada-html5/
    Mengenal CSS
    Margin
    Margin (dalam pengertian CSS) adalah ruang disekitar elemen/konten. Margin akan membentuk daerah (ruang) vertikal dan horizontal antara elemen. Jika elemen/konten tidak memilki margin, maka elemen-elemen tersebut akan rapat bertemu terhadap satu sama lain. Agar margin bekerja dengan baik, elemen biasanya diikuti oleh posisi float atau diposisikan relative. Style ini sering diterapkan untuk dapat memindahkan elemen lain di sekitarnya.
  


Padding
Jadi bagaimana dengan padding? Nah, padding adalah ruang horizontal dan vertikal yang diatur di sekitar area isi/konten dari elemen yang ditargetkan. Jadi padding di bagian dalam kotak, bukan di luar.

Padding juga dapat dipahami sebagai “filling”. Karena  padding tidak mempengaruhi jarak dari elemen ke elemen lainnya tetapi hanya mendefinisikan jarak inner antara tepi/border dan isi dari elemen.

Border
Border/garis tepi dapat digunakan untuk banyak hal, misalnya sebagai elemen dekoratif atau untuk memberi garis batas pemisah dari dua hal. Border properti mendefinisikan width, color, and style dari batas area pada box/kotak.

Link :

  http://problogiz.blogspot.com/2012/12/pengertian-margin-padding-dan-border.html


Membuat Layout

###

Tools Front End

React JS

Responsive Web Development

Viewport Meta Tag

CCS3 Media Queries

</content>
      <categories>
        
          <category> tutorial </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Pengenalan Teknik - teknik request http pada javascript</title>
      <url>/2019/03/11/teknik-http-request/</url>
      <content type="text">AJAX
Ajax adalah cara paling tradisional yang melakukan request HTTP. Data bisa dikirim dengan menggunakan method HTTP POST dan menerima data dengan HTTP GET.

Untuk membuat HTTP call di Ajax, kita perlu membuat sebuah objek XMLHttpRequest(), menentukan URL endpoint dan HTTP method-nya. Selanjutnya kita memanggil method open() untuk membuka koneksi ke URL yang dimasukkan menggunakan HTTP method yang diinginkan. Method send() akan memulai proses koneksi yang sebelumnya sudah dibuka oleh open().

Method onreadystatechange dipanggil saat objek Http telah berhasil mendapat data yang diperlukan atau gagal. Ia memiliki dua method yaitu readyState dan status untuk memeriksa status request yang dilakukan.

Fetch
fetch adalah salah satu tool yang membantu melakuan request Asynchronous dengan lebih mudah. Ia mengembalikan sebuah Promise yang merupakan salah satu fitur andalan ES6. Perhatikan bagaimana cara penggunaan fetch di bawah ini:

*code
const API = ‘https://hn.algolia.com/api/v1/search?query=’;

fetch(API + DEFAULT_QUERY)
      .then(response =&amp;gt; {
        if (response.ok) {
          return response.json();
        } else {
          throw new Error(‘Something went wrong …’);
        }
      })
      .then(data =&amp;gt; this.setState({ hits: data.hits, isLoading: false }))
      .catch (error =&amp;gt; this.setState({ error, isLoading: false }));
*

Fungsi fetch meminta sebuah parameter yaitu alamat URL endpoint. Ia juga bisa menerima parameter lain sebagai query parameter untuk URL yang diberikan.

Axios

Link : https://www.codepolitan.com/teknik-teknik-melakukan-request-http-di-javascript-5afa5536d44e9
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>React VS Angular</title>
      <url>/2019/01/17/React-JS-vs-Angular-JS/</url>
      <content type="text">React

  React is a JavaScript library developed by Facebook to manage the user interface for web applications with ease. One of the main highlights of React is that it helps in creating manageable UI components, which makes it easier to scale large web applications. React works on the concept of Virtual DOM, where it keeps a mirror image of the actual DOM. Whenever a change occurs, React runs a diffing process, identifies the change, and updates it to the actual DOM. The concept of Virtual DOM makes app rendering faster and improves performance.


Dalam sebuah komponen dalam react, terdapat tiga lifecycle berikut:
Inisialisasi / mounting (ketika komponen dibuat/ditambahkan pertama kali pada DOM)
Update / rerender (ketika terdapat perubahan state/prop yang mengakibatkan perubahan pada DOM)
Unmounting (ketika komponen akan dihapus dari DOM)

DOM (Document Object Model)

dikarenakan javascript dapat berinteraksi dengan HTML
DOM(Document Object Model) adalah model data standar. DOM adalah cara javascript melihat suatu halaman html. DOM adalah sebuah platform dan interface yang memperbolehkan pengaksesan dan perubahan pada konten, struktur, dan style pada sebuah dokumen oleh program dan  script. Istilah HTML DOM mengacu kepada dokumen html. Kasusnya disini ialah konten, struktur, dan style pada dokumen html dapat diakses dan dirubah dengan menggunakan sintaks javascript.
Pada model DOM ini, setiap elemen html dipandang sebagai sebuah object. Setiap object bisa terdiri dari object-object lain, sama halnya dengan dokumen html yang terdiri dari elemen root (elemen &amp;lt;html&amp;gt;), elemen root terdiri dari elemen &amp;lt;head&amp;gt; dan elemen &amp;lt;body&amp;gt;, elemen &amp;lt;body&amp;gt; boleh jadi terdiri dari elemen , &amp;lt;h1&amp;gt;, &amp;lt;p&amp;gt;, dst. Elemen-elemen pada dokumen html membentuk sebuah object document yang merupakan object dari dokumen html itu sendiri. Dibawah ini adalah representasi HTML DOM dalam model pohon:

dom_tree
Kalau dalam pemrograman OOP(Object Oriented Programing), sebuah object memiliki property dan method, begitu juga elemen pada dokumen html ini memiliki property yaitu nilai pada elemen html yang bisa ditetapkan atau dirubah dan method yakni aksi yang dapat dilakukan pada elemen html. Contoh property yang biasa digunakan ialah innerHTML yang digunakan untuk memperoleh atau merubah konten dari elemen html itu sendiri. Kemudian method, contoh misalnya getElementById(“id”) milik object document yang digunakan untuk mengakses elemen html dalam dokumen html berdasarkan id.

Virtual DOM
Dari pada langsung bekerja dengan DOM secara langsung pada browser, pada virtual DOM kita terlebih dahulu membuat abstraksi DOM dalam bentuk virtual. Sehingga setiap perubahan terhadap struktur dokumen tidak terjadi secara langsung pada permukaan browser, akan tetapi terjadi di dalam memory. Sehingga proses menjadi lebih cepat.

Setelah modifikasi pada Virtual DOM selesai, kita lakukan proses differing untuk membedakan antara struktur tree yang telah dirender sebelumnya pada browser dengan virtual tree yang sudah dibuat. Sehingga akan menghasilkan bagian-bagian yang ‘kotor’ alias berbeda. Dan hanya bagian yang butuh diubah saja yang kita render ulang.

Proses ini tentu jauh lebih efektif dan lebih cepat dari pada jika kita harus bekerja secara langsung pada DOM yang asli.

Lantas, bagaimana cara implementasinya?
Oke, jawaban ini cukup rumit. Karena secara umum –pada virtual dom– kita akan menemui dua permasalahan:

Kapan kita harus melakukan render ulang?
Dan bagaimana cara kita untuk mengetahui bagian mana saja yang berubah dari struktur tree yang lama?
Karena jawaban dari dua pertanyaan di atas adalah kunci kenapa Virtual DOM bisa resource-cheap atau lebih cepat. Kalau anda salah dalam menentukan kapan sistem harus melakukan render ulang, maka aplikasi anda akan tidak jelas dan tidak interaktif. Plus bisa menjadi super-lemot jika ternyata aplikasi anda selalu merender ulang padahal proses tersebut sedang tidak diperlukan. Atau pada proses kedua –yaitu proses differing/comparing tree lama dan yang baru–, kalau anda tidak menggunakan algoritma yang efektif dan efisien, maka teknik Virtual DOM yang anda gunakan akan lebih lelet dari pada cara yang konvensional.

Flux

  Flux adalah konsep pemrograman untuk mengolah data. Pada react hal ini sangat terkait dengan pengelolaan state pada komponen. Flux memberikan banyak manfaat untuk pengolahan data tersebut. Silahkan simak ulasan ini untuk mengetahui fungsi flux pada react.


Flux merupakan konsep pemrograman yang mengatur aliran atau flow dari data. Pada konsep flux data dibuat menjadi uni-directional. Artinnya , seluruh data akan masuk ke dalam satu gerbang yang kemudian baru di distribusikan pada komponen-komponen didalamnya. Ilustrasinnya seperti saat kita masuk ke kelas yang memiliki satu pintu, seluruh siswa harus masuk ke dalam pintu tersebut yang secara otomatis “pintu” itu akan mengenali seluruh siswa yang masuk dan pada ahirnya mereka menuju ke bangku mereka masing-masing.

1.Action , yaitu suatu object yang akan mentrigger aliran data. Actions akan menentukan data yang akan dikirimkan ke store melalui dispatcher. lebih detailnya, action adalah suatu javascript object yang menggunakan property berupa “type”  yang berfungsi untuk memberitahukan kepada dispatcher mengenai data yang harus disimpan pada store. Action ini akan mentrigger perubahan pada suatu komponen namun tidak dapat menspesifikan pada bagian mana yang harus berubah. Reducer merupakan modul yang dapat melakukan hal tersebut.
Dispatcher, yaitu object yang berfungsi layaknya suatu router. Data – data yang tersentral tersebut tentunnya akan dibagikan ke komponen-komponen lain. Disinilah peran dari suatu dispatcher.
Store, tempat untuk menyimpan state dan data-data logical lainnya. State pada store dapat diupdate secara parsial ketika memang dibutuhkan
View, object yang menerima data dari store dan melakukan proses rendering

React nya biasa nya digunakan untuk pengerjaan proyek2 kecil dikarenakan konsep library dimana dapat menentukan yang mau dipakai jadinya tidak banyak pilihan yang tersedia

contoh aplikasi yang menggunakan react :

  Facebook
  AirBnb
  Uber
  Netflix
  Instagram
  Whatsapp
  Dropbox


Initialization
Pada initialization, terdapat 3 methods yang akan dieksekusi yaitu componentWillMount, render dan componentDidMount. Method tersebut dieksekusi sesuai urutan pada gambar di atas dengan urutan dari atas ke bawah.
ComponentWillMount akan dieksekusi paling awal pada saat pertama kali komponen dibuat, sebelum method render dieksekusi.
Render merupakan method yang wajib ada pada setiap komponen pada react. Method ini akan mengembalikan sebuah react element yang merupakan representasi dari DOM komponen.
Setelah method render dieksekusi, selanjutnya componentDidMount akan dieksekusi. Kita dapat mengakses DOM dan memanipulasi DOM atau melakukan proses pengambilan data atau AJAX request pada method ini. Selain itu, jika kita menggunakan JavaScript framework lain seperti jQuery, kita dapat memanggilnya pada method ini.

Update / rerender

Proses ini merupakan phase dimana komponen akan di-render ulang. Proses render ulang sebuah komponen dapat dipicu dari perubahan props atau state pada komponen tersebut.

Pada gambar di atas terdapat 5 methods yang akan dieksekusi. Method tersebut adalah componentWillReceiveProps, shouldComponentUpdate, componentWillUpdate, render, componenDidUpdate. Urutan eksekusi ditunjukkan pada gambar di atas dengan urutan dari atas ke bawah.
ComponentWillReceiveProps akan dieksekusi ketika terdapat perubahan pada props dan bukan merupakan render komponen yang pertama kali. Method ini dapat digunakan untuk mengubah state sesuai dengan props baru yang diterima. Perubahan state pada method ini tidak akan memicu phase update pada komponen (tidak akan merender komponen).
ShouldComponentUpdate selalu dieksekusi sebelum method render. Method ini merupakan penentu apakah sebuah komponen akan di-render ulang atau tidak. Method shouldComponentUpdate mengembalikan nilai true atau false dengan nilai default adalah true. Jika method ini mengembalikan nilai true, maka komponen akan di-render ulang dan berlaku juga sebaliknya.
ComponentWillUpdate akan dieksekusi jika method shouldComponenUpdate mengembalikan nilai true. Pada method ini, kita tidak dianjurkan untuk mengubah state dengan alasan bahwa method ini digunakan untuk mempersiapkan proses update komponen bukan untuk memicu proses update komponen.
Setelah componentWillUpdate selesai dieksekusi, maka method render akan dieksekusi.
Setelah method render selesai dieksekusi, componentDidUpdate akan dieksekusi. Method ini sama dengan method componentDidMount. Method ini dapat digunakan untuk interaksi dengan DOM setelah komponen selesai di-render.
Unmounting
Pada proses unmounting hanya ada satu method yang akan dieksekusi yaitu componentWillUnmount. Method ini akan dieksekusi sebelum komponen dihapus atau dihilangkan dari DOM.
Implementasi Kode
Setelah memahami component lifecycle, untuk lebih memahami setiap phase dari component lifecycle, saya telah membuat kode yang akan menunjukkan urutan eksekusi method pada setiap phase.
Implementasi dengan menggunakan react, react-dom dan webpack-dev-server.

Keunggulan React js ?
Mudah dipahami
Gaya penulisan yang deklaratif membuat react js mudah dipahami dan membuat react mudah di prediksi jika ada kesalahan penulisan kode.
JSX
JSX adalah sebuah extension javascript yang di gunakan react untuk menulis HTML di dalam Javascript. JSX bukanlah sintaks javascript, sehingga browser tidak bisa membaca sintaks ini, di butuh kan sebuah JSX compiler yang di gunakan untuk menterjemahkan JSX kedalam bahasa regular javascript agar bisa terbaca oleh browser. Saya sendiri menggunakan BABEL JS sebagai JSX compilernya.
Modular
Untuk membuat aplikasi dengan skala besar, kita dapat menulis kode-kode dengan skala yang lebih kecil untuk di satukan menjadi aplikasi utuh, dan dapat di gunakan kembali (reusable).
Scalable
React js dapat menangani dengan sangat baik sebuah program dengan skala yang besar yang dapat menampilkan perubahan data yang sangat kompleks.
Flexibel
Dengan belajar 1 libary saja kita dapat membuat aplikasi Web, Moblie, maupun Desktop.
Effisien dan Cepat
React JS menciptakan Virtual DOM untuk mempercepat urusan perubahan DOM. Semua operasi di kerjakan di dalam Virtual DOM, setelah operasi selesai React JS menulis perubahan tersebut di dalam DOM. Contoh kasusnya seperti ini: “Jika kita menulis dalam secarik kertas menggunakan spidol, apabila terjadi kesalahan penulisan kita harus menulis di kertas yang baru. Berbeda jika kita menggunakan pensil, cukup menghapus dan memperbaiki pada bagian yang salah ”.
Mudah Debugging
Ketika kita mulai menggunakan React JS, jangan lupa menginstall extensi resmi React JS. Kita dapat dengan mudah menjelejah Virtual DOM pada aplikasi yang sudah kita buat, sehingga jika ada bug bisa cepat ditemukan.
SEO Bagus
Salah satu masalah terbesar dari library Javascript pada umumnya adalah mereka sidak support search engine. Meskipun sudah banyak perbaikan, mesin pencari umumnya masih mengalami kesulitan. Namun tidak dengan React JS, kita dapat menjalankan React JS pada server dan Virtual DOM diberikan ke browser sebagai halaman web biasa, sehingga sangat support SEO.
Kelemahan react js ?
Meskipun React JS sangat powerfull, namun juga memiliki beberapa kelemahan antara lain:
Hanya View Layer
React js hanya sebuah pustaka View Layer, untuk membangun aplikasi besar kita harus menyusun sendiri kebutuhan aplikasi lainya seperti data layer, router, struktur aplikasi dan event system(kecuali event DOM).
Dokumentasi tidak bagus
Beberapa sumber artikel yang saya baca mengatakan bahwa dokumentasi react js tidak bagus karena informasi yang di berikan tidak lengkap, meskipun seperti itu kita tetap bisa mempelajarinya kok, tentunya dengan semangat dan ketekunan.
Permasalahan lisensi
Baru-baru ini muncul issue tentang lisensi react. Sebetulnya issue ini sudah ada sejak 2015, namun tampaknya ada pihak-pihak yang belum puas dan mempermasalahkanya. Menurut pemahaman saya bahwa “facebook memperbolehkan kita menggunakan react js untuk mengembangkan produk kita dengan catatan tidak untuk berkompetisi dengan produknya facebook”. Tapi sebenarnya ini tidak masalah , temen-teman bisa baca penjelasanya detail disini.
Dukungan browser
React js tidak mendukung browser versi lama, hanya browser versi baru. React js menghentikan dukungan pada browser Internet Explorer versi 8, sampai saat ini react yang bisa jalan di IE 8 adalah react versi v0.14. Versi terbaru dari react hanya mendukung Internet Explorer versi 9 keatas.

Mengapa harus pakai react js ?
React js mudah di pahami.
Konsep Components pada react js merupakan konsep pengembangan web modern.
Jika data elements pada aplikasi kita berubah setiap satuan waktu, maka kita bisa menggunakan react sebagai solusinya.
Jika dalam satu team sama-sama sedang belajar react, maka pengembangan aplikasi bisa lebih cepat.

JSX
JSX is a JavaScript syntax extension which looks similar to XML. Here is an example:

When compared to JavaScript, it’s easier to write JSX. It is as simple as opening and closing XML tags. Here is a JSX example:


Welcome to TutsPlus

Here is the compiled React code: 
“use strict”;

React.createElement(
  “div”,
  null,
  React.createElement(
    “p”,
    null,
    “Welcome to TutsPlus”
  )
);

  
    JSX code ensures readability and makes maintainability easier.
  
  
    JSX optimizes the code while compiling, so it runs faster compared to the equivalent JavaScript code.
  


Angular
Dalam angular untuk yang dikategorikan sebagai framework, angular mempunyai struktur untuk proyek yang lebih kompleks. Tentunya Angular digunakan untuk

contoh aplikasi yang menggunakan angular adalah berikut ini :

  Eat24
  CVS shop
  onefootball
  Google Express
  NBA
  Delta
  wix.com


Persamaan

Perbedaan

Unidirectional VS Bidirectional

</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Belajar Javascript Part 1</title>
      <url>/2018/11/06/belajar-javascript-part-1/</url>
      <content type="text">#Function Executions
Kebanyakan pembuatan app menggunakan Javascript dibangun dengan V8, yaitu runtime yang dimiliki oleh chrome. untuk pemahaman lebih lanjut dapat ditonton video yang dijelaskan oleh Philip Robert,
What the heck is the event loop anyway?
Call Stack

  It’s a data structure which records the function calls, basically where in the program we are. If we call a function to execute , we push something on to the stack, and when we return from a function, we pop off the top of the stack.


sebelum memulai call stack memahami terlebih dahulu tentang Execution Context.
Execution Context

Call Stack merupakan pemanggilan fungsi - fungsi menggunakan konsep Stack. Stack merupakan sturktur data dimana data dipanggil dengan Last In First Out(LIFO) ketika fungsi pada javascript paling belakang, maka akan tercetak

Heap

  Objects are allocated in a heap i.e mostly unstructured region of memory. All the memory allocation to variables and objects happens here.


Queue

  A JavaScript runtime contains a message queue, which is a list of messages to be processed and the associated callback functions to execute. When the stack has enough capacity, a message is taken out of the queue and processed which consists of calling the associated function (and thus creating an initial stack frame). The message processing ends when the stack becomes empty again. In basic words , these messages are queued in response to external async events(such as a mouse being clicked or receiving the response to an HTTP request), given a callback function has been provided. If, for example a user were to click a button and no callback function was provided — no message would have been enqueued.


Event Loop

  Basically, when we evaluate the performance of our JS code, so a function in a stack makes it slow or fast, console.log() will be fast but performing iteration with for or while over thousands or millions of line items will be slower, and will keep the stack occupied or blocked. This is termed as blocking script, which you have read or heard about in Webpage Speed Insights.
Network requests can be slow, the image requests can be slow, but thankfully the server requests can be done through AJAX, an asynchronous function. If suppose, these network requests are made through synchronous functions, then what would happen? The network requests are send to some server, which is basically another computer/machine somewhere. Now, computers can be slow sending back the response. In the meantime , if I click some CTA button, or some other rendering needs to be done, nothing will happen as the stack is blocked. In multi threaded language like Ruby, it can be handled, but in single threaded language like Javascript, this is not possible unless function inside the stack returns a value. The webpage will hell breaks loose as the browser can’t do anything. This is not ideal if we want fluid UI for the end user. How do we handle this?


Monkey Patch
A monkey patch is a way for a program to extend or modify supporting system software locally (affecting only the running instance of the program).
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Belajar Nest JS Part 2</title>
      <url>/2018/11/02/belajar-nest-js-part-2/</url>
      <content type="text">
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Belajar Nest JS Part 1</title>
      <url>/2018/11/01/belajar-nest-js-part-1/</url>
      <content type="text">
  Nest is a framework for building efficient, scalable Node.js server-side applications. It uses progressive JavaScript, is built with TypeScript (preserves compatibility with pure JavaScript) and combines elements of OOP (Object Oriented Programming), FP (Functional Programming), and FRP (Functional Reactive Programming).
Under the hood, Nest makes use of Express, but also provides compatibility with a wide range of other libraries (e.g. Fastify). This allows for easy use of the myriad third-party plugins which are available.


Untuk melakukan instalasi, saya menggunakan git

git clone https://github.com/nestjs/typescript-starter.git project
cd project
npm install
npm run start


or

npm i -g @nestjs/cli
nest new nest-restaurant-api
npm run start:dev


setelah di clone, otomatis membuat template dari Nets JS. kemudian setelah run di terminal dapat membuka di browser localhost:3000 maka muncul output seperti gambar di bawah ini

kemudian untuk menghubungkan database MongoDB dengan mongoose, buat folder database di dalam folder src

src
  database
    database.module.ts
    database.providers.ts


setelah buka file database.module.ts dan isikan kode dibawah ini

import * as mongoose from 'mongoose';
import { DB_PROVIDER } from '../constants';

export const databaseProviders = [
    {
        provide: DB_PROVIDER,
        useFactory: async () =&amp;gt; {
            (mongoose as any).Promise = global.Promise;
            return await mongoose.connect('mongodb://localhost:27017/parley');
        },
    },
];


pada {DB_PROVIDER} module yang dipanggil tidak ada, buat file constants.ts

export const DB_PROVIDER = 'DbConnectionToken';


setelah berhasil menghubungkan MongoDB dengan Nest JS, install MongoDB dengan perintah
npm i --save mongoose
npm i --save-dev


setelah itu untuk mengakses alamat MongoDB yaitu mongodb://localhost:27017/parley dan otomatis membuat database dengan nama parley.

Kemudian definisikan database ke modul di dalam file database.module.ts

import { Module } from '@nestjs/common';
import { databaseProviders } from './database.providers';

@Module({
    components: [...databaseProviders],
    exports: [...databaseProviders],
})
export class DatabaseModule { };


setelah itu baru kita bisa menarik database modul di dalam modul2 lain dan menggunakan mongoose untuk menghubungkan objek untuk dijalankan query nya di database.

Post module
Kemudian mendesain app nya pendekatan dari entitas berbasis modular. Untuk membuat direktori modul pertama di dalam  direktori src.

src
  -posts
    --dto
      ---create-post.dto.ts
    --interfaces
      --post.interface.ts
    --posts.controller.ts
    --posts.module.ts
    --posts.providers.ts
    --posts.schema.ts
    --posts.service.ts


pada dto kita mendefinisikan struktur data untuk API endpoint. Ketika membuat

export class CreatePostDto {
    readonly title: string;
    readonly content: string;
    readonly userId: string;
}


kemudian kita membuat post interface di posts.interface.ts

import { Document } from 'mongoose';

export interface Post extends Document {
    readonly title: string;
    readonly content: string;
    readonly userId: string;
}

ketika sudah membuat 2 file diatas sekarang membuat post service pada posts.service.ts. Untuk postService membuat komponen kelas konstruktor , untuk menginjeksi dimana Nest JS melakukan depedency injection.

import { Model } from 'mongoose';
import { Component, Inject } from '@nestjs/common';

import { Post } from './interfaces/post.interface';
import { CreatePostDto } from './dto/create-post.dto';
import { POST_MODEL_PROVIDER } from '../constants';

@Component()
export class PostsService {
    constructor(
        @Inject(POST_MODEL_PROVIDER) private readonly postModel: Model&amp;lt;Post&amp;gt;) { }

    async create(createPostDto: CreatePostDto): Promise&amp;lt;Post&amp;gt; {
        const createdPost = new this.postModel(createPostDto);
        return await createdPost.save();
    }

    async findAll(): Promise&amp;lt;Post[]&amp;gt; {
        return await this.postModel.find().exec();
    }
}


Di dalam provider, membangun mongoose model dan injeksi model. Untuk membuat model, kita harus mendefiniskan skema pada file posts.schema.ts

import * as mongoose from 'mongoose';

export const PostSchema = new mongoose.Schema({
    title: {
        type: String,
        required: true,
    },
    content: {
        type: String,
        required: false,
    },
    userId: {
        type: mongoose.SchemaTypes.ObjectId,
        required: true,
    }
});

Kegunaan pada file src
app.controller.ts and app.service.ts: those files are responsible for generating the message Hello world when the endpoint / is accessed through the browser. Because this endpoint is not important to this application you may delete these files as well. Soon you are going to learn in more details what controllers and services are.
app.module.ts: this is a class of the type module that is responsible for declaring imports, exports, controllers, and providers to a Nest.js application. Every application has at least one module but you may create more than one module for more complex applications (more details on Nest.js documentation). The application of this tutorial will have only one module.
main.ts: this is the file responsible for starting the server.
main.hrm.ts: is a Hot Module Replacement file that installs modules during the server execution and it is useful to speed up the development process.

Penjelasan REST API

  RESTful API / REST API merupakan implementasi dari API (Application Programming Interface). REST (Representional State Transfer) adalah suatu arsitektur metode komunikasi yang menggunakan protokol HTTP untuk pertukaran data dan metode ini sering diterapkan dalam pengembangan aplikasi. Dimana tujuannya adalah untuk menjadikan sistem yang memiliki performa yang baik, cepat dan mudah untuk di kembangkan (scale) terutama dalam pertukaran dan komunikasi data




URL Design
RESTful API diakses menggunakan protokol HTTP. Penamaan dan struktur URL yang konsisten akan menghasilkan API yang baik dan mudah untuk dimengerti developer. URL API biasa disebut endpoint dalam pemanggilannya. Contoh penamaan URL / endpoint yang baik adalah seperti berikut :

/users
/users/1234
/users/1234/photos
/users/1234/photos/abc
HTTP Verbs
Setiap request yang dilakukan terdapat metode yang dipakai agar server mengerti apa yang sedang di request client, diantaranya yang umum dipakai adalah :

GET
GET adalah metode HTTP Request yang paling simpel, metode ini digunakan untuk membaca atau mendapatkan data dari sumber.
Contoh :
GET /users : Mengembalikan daftar user
GET /users/1234 : Mengembalikan data user dengan ID 1234

POST
POST adalah metode HTTP Request yang digunakan untuk membuat data baru dengan menyisipkan data dalam body saat request dilakukan.
Contoh :
POST /users : Membuat data user baru

PUT
PUT adalah metode HTTP Request yang biasanya digunakan untuk melakukan update data resource.
Contoh :
PUT /users/1234 : Mengupdate data user dengan ID 1234

DELETE
DELETE adalah metode HTTP Request yang digunakan untuk menghapus suatu data pada resource.
Contoh :
DELETE /users/1234 : Menghapus data user dengan ID 1234

Selain HTTP Verbs diatas, masih ada metode HEAD dan PATCH dalam HTTP Request, tetapi jarang sekali digunakan.

HTTP Response Code
HTTP response code adalah kode standarisasi dalam menginformasikan hasil request kepada client. Secara umum terdapat 3 kelompok yang biasa kita jumpai pada RESTful API yaitu :

2XX : adalah response code yang menampilkan bahwa request berhasil.
4XX : adalah response code yang menampilkan bahwa request mengalami kesalahan pada sisi client.
5XX : adalah response code yang menampilkan bahwa request mengalami kesalahan pada sisi server.

Dan berikut ini adalah response code yang biasa digunakan pada REST :

200 OK
Response code ini menandakan bahwa request yang dilakukan berhasil.

201 Created
Response code ini menandakan bahwa request yang dilakukan berhasil dan data telah dibuat. Kode ini digunakan untuk mengkonfirmasi berhasilnya request PUT atau POST.

400 Bad Request
Response code ini menandakan bahwa request yang dibuat salah atau data yang dikirim tidak ada.

401 Unauthorized
Response code ini menandakan bahwa request yang dibuat membutuhkan authentication sebelum mengakses resource.

404 Not Found
Response Code ini menandakan bahwa resource yang di dipanggil tidak ditemukan.

405 Method Not Allowed
Response code ini menandakan bahwa request endpoint ada tetapi metode HTTP yang digunakan tidak diizinkan.

409 Conflict
Response code ini menandakan bahwa request yang dibuat terdapat duplikasi, biasanya informasi yang dikirim sudah ada sebelumnya.

500 Internal Server Error
Response code ini menandakan bahwa request yang dilakukan terdapat kesalahan pada sisi server atau resource.

Format Response
Setiap request yang dilakukan client akan menerima data response dari server, response tersebut biasanya berupa data XML ataupun JSON. Setelah mendapatkan data response tersebut barulah client bisa menggunakannya dengan cara memparsing data tersebut dan diolah sesuai kebutuhan.
Contoh :
XML

HTTP/1.1 200 OK
Date: Sat, 06 Oct 2001 23:20:04 GMT
Server: Apache.1.3.12 (Unix)
Connection: close
Content-Type: text/xml
Content-Length: 124





18.24668429131
&amp;lt;/param&amp;gt;


JSON

GET /users/1234

HTTP/1.1 200 OK
Content-Type: application/vnd.api+json

{
“id”: “1234”,
“first_name”: “jhon”,
“last_name”: “doe”,
“created”: “2015-05-22T14:56:29.000Z”,
“updated”: “2015-05-22T14:56:29.000Z”
}
Penjelasan Tentang Mongoose
Mongoose adalah sebuah Object Document Mapper (ODM). Ini berarti Mongoose mengizinkan Anda untuk mendefinisikan obyek dengan skema yang benar-benar diketik yang dipetakan ke sebuah dokumen MongoDB.

Mongoose menyediakan jumlah fungsionalitas yang luar biasa yang berkaitan dengan pembuatan dan pengerjaan skema. Mongoose saat ini memiliki delapan tipe skema dimana propertinya disimpan seperti saat berada di MongoDB. Diantaranya:

String
Number
Date
Buffer
Boolean
Mixed
ObjectId
Array
Setiap tipe data memungkinkan Anda untuk menentukan:

sebuah nilai default
sebuah fungsi validasi custom
menunjukan field yang dibutuhkan
fungsi get yang memungkinkan Anda untuk memanipulasi data sebelum dikembalikan sebagai obyek
sebuah set fungsi yang memungkinkan Anda untuk memanipulasi data sebelum disimpan ke database
membuat indeks yang memungkinkan data agar ditarik secara lebih cepat
Selanjutnya untuk opsi umum ini, tipe data tertentu memungkinkan Anda untuk menyesuaikan lebih lanjut bagaimana data disimpan dan diambil dari database. Sebagai contoh, sebuah tipe data String juga memungkinkan Anda untuk menentukan pilihan tambahan sebagai berikut:

mengubah menjadi huruf kecil
mengubah menjadi huruf besar
memangkas data sebelum disimpan
regular-expression yang dapat membatasi data yang diizinkan untuk disimpan selama dalam proses validasi
sebuah enum yang dapat menentukan daftar string yang valid
Properti Number dan Date keduanya mendukung penentuan nilai minimal dan maksimal yang diizinkan untuk field tersebut.

Sebagian besar dari delapan jenis data yang diizinkan seharusnya cukup familiar untuk Anda. Namun, ada beberapa pengecualian yang mungkin menjadi pengecualian bagi Anda, seperti Buffer, Mixed, ObjectId, dan Array.

Tipe data Buffer memungkinkan Anda untuk menyipan data biner. Contoh yang umum untuk data biner seperti gambar atau file encodem seperti dokumen PDF.

Tipe data Mixed mengubah properti menjadi field “dapat menjadi apa saja”. Field ini menyerupai berapa banyak pengembang yang menggunakan MongoDB karena tidak ada struktur yang jelas. Berhati-hatilah menggunakan tipe data ini karena tipe ini kehilangan banyak fitur hebat yang disediakan oleh Mongoose, seperti validasi data dan pendeteksi perubahan entitas untuk dapat mengetahui secara otomatis dalam memperbarui properti saat menyimpan.

Tipe data ObjectId umumnya menentukan sebuah tautan ke dokumen yang lain di dalam database Anda. Sebagai contoh, jika anda memiliki sebuah koleksi buku dan penulis, dokumen buku kemungkinan berisi sebuah properti ObjectId yang menunjuk ke penulis tertentu dari dokumen.

Tipe data Array memungkinkan anda untuk menyimpan array yang seperti JavaScript. Dengan sebuah tipe data Array, anda dapat melakukan operasi array Javascript yang umum, seperti push, pop, shift, slice, dll.
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Part 1 Belajar Ios</title>
      <url>/2018/10/11/part-1-belajar-iOS/</url>
      <content type="text">
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Belajar Android dengan Firebase Part 1</title>
      <url>/2018/10/05/part-1-firebase-android-findingbpjs/</url>
      <content type="text">Firebase

Membuat Model untuk informasi dari user dan untuk menyimpan data ke dalam tabel firebase

Membuat
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Pengenalan Deep Learning</title>
      <url>/2018/07/15/part-1-pengenalan-neural-network/</url>
      <content type="text">Artificial Intelligence
Neural Network
Machine Learning
Deep Learning
Sebelum mengenal
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Pertemuan 2 Mata Kuliah Pengantar Komputasi Modern</title>
      <url>/tugas%20kuliah/2018/04/28/pertemuan-2-pengantar-komputasi-modern/</url>
      <content type="text">Map Reduce
MapReduce merupakan model pemrograman untuk memproses data berukuran besar secara terdistribusi dan paralel dalam cluster yang terdiri atas ribuan komputer

Map
Proses Map yaitu mengumpulkan informasi dari potongan - potongan data dari komputer - komputer yang saling terhubung.

Reduce
Hasil dari proses Map di arakhkan ke proses Reduce yaitu mengirimkan hasil akhr kepada pengguna.

produk

  Apache Hadoop
  Pig
  Cascading
  Microsoft Dryad
  IBM MapReduce Tool for   Eclipse  
  Skynet
  CouchDB


NoSQL
NoSQL adalah sebuah konsep mengenai penyimpanan data non-relasional. NoSQL sangat berguna pada data-data yang terus-menerus berkembang, dimana  data tersebut sangat kompleks sehingga sebuah database relational tidak lagi bisa mengakomodir


  Kelebihan NoSQL


NoSQL bisa menampung data yang terstruktur, semi terstruktur dan tidak terstuktur secara efesien dalam skala besar.
Menggunakan OOP dalam pengaksesan atau manipulasi datanya.
jika database noSQL di jalankan di cluster server (multiple server) maka data akan tersebar secara otomatis dan merata keseluruh server


  Kekurangan NoSQL


Hostingnya mahal. beberapa layanan di luar negeri mencharge biaya 100-200USD untuk hosting database noSQL
Sulitnya mencari hosting Cpanel yang mendukung database MongoDB atau database noSQL lainnya

CouchDB
CouchDB yang dikembangkan oleh Apache lebih dulu muncul jauh sebelum mongoDB yaitu pada tahun 2005. CouchDB tidak menyimpan datanya dalam tabel melainkan dalam dokumen seperti halnya mongoDB.
Basis data ini juga merupakan proyek open source serta dikembangkan dalam bahasa pemrograman Erlang oleh karena itu kita bisa ikut berkontribusi dalam pengembangan CouchDB agar basis data ini lebih baik.



Cassandra
Cassandra merupakan sebuah sistem penyimpanan data terdistribusi untuk menangani jumlah data yang sangat besar dan terstruktur. Cassandra juga dikembangkan Apache.

Cassandra juga merupakan aplikasi open source yang ditulis dalam bahasa Java dengan lisensi Apache License 2.0.

Untuk memproses datanya, Cassandra menggunakan bahasa sendiri yang mirip dengan SQL yaitu Cassandra Query Language (CQL).



MongoDB

MongoDB merupakan basis data yang paling populer diantara basis data NoSQL lainnya. Hal ini dikarenakan pemasangan maupun penggunaan mongoDB tidaklah sulit atau merepotkan penggunanya. Selain itu mongoDB juga merupakan salah satu basis data yang open source.
MongoDB merupakan basis data NoSQL yang document based. Ia menyimpan data-datanya dalam suatu dokumen JSON yang disebut BSON (Binary JSON).
Dikembangkan sejak tahun 2009, mongoDB sekarang telah mendukung hampir semua bahasa pemrograman untuk dapat berinteraksi dengan mongoDB.



Riak
Riak merupakan basis data NoSQL terdistribusi yang menyimpan datanya dalam bentu key-value. Riak menawarkan fitur high availability, fault tolerance, operational simplicaity, dan scalability.

Riak memiliki dua versi yakni Open source edition dan Enterprise edition. Enterprise edition menawarkan dukungan berbayar intensif dari pengembangnya. Pengguna Open source edition dapat bermigrasi kapan saja ke Enterprise edition jika dibutuhkan. Erlang ditulis dalam bahasa pemrograman Erlang dengan lisensi Apache License 2.0



Redis
Redis merupakan basis data berbasis key-value. Redis merupakan singkatan dari REmote DIctionary Server. Basis data ini dikembangkan oleh Salvatore Sanfilippo pada tahun 2009 dan ditulis dalam bahasa C. Redis banyak dipilih karena memiliki fitur in-memory, networked, dan durabilitas tinggi.

Redis mendukung banyak bahasa pemrograman seperti ActionScript, C/C++, C#, Clojure, Common LIsp, Dart, Erlang, Go, Haskell, Haxe, Io, Java, JavaScript (Node.js), Lua, Objective-C, Perl, PHP, Pure Data, Python, R, Ruby, Scala, Smalltalk, dan Tcl.



Quantum Computation

Quantum computation atau komputasi quantum merupakan sebuah perhitungan yang menggunakan kuantum mekanika fenomena yang dilakukan untuk melakukan operasi data

Entaglement
Entanglement adalah suatu teori mekanika quantum yang menggambarkan seberapa cepat dan betapa kuatnya keterhubungan partikel-partikel pada Quantum computer yang dimana jika suatu partikel diperlakukan “A” maka akan memberikan dampak “A” juga ke partikel lainnya

Quantum Gates
Quantum gates merupakan gerbang dari kuantum yang berfungsi mengoperasikan bit yang terdiri dari 0 dan 1 juga dalam qubits sehingga proses yang terjadi lebih cepat, karena setiap perhitungan dilakukan secara bersamaan



Pengoperasian Data Qubit
Dalam komputer kuantum, sejumlah partikel elemental seperti elektron atau foton dapat digunakan yang  bertindak sebagai representasi dari 0 dan  1. Setiap partikel-partikel ini dikenal sebagai qubit, sifat dan perilaku partikel-partikel ini membentuk dasar dari komputasi kuantum.
Namun dalam mekanika quantum, objek apapun yang memiliki dua status berbeda pasti memiliki rangkaian status potensial, disebut superposisi, yang menjerat kedua status hingga derajat bermacam-macam.


Algoritma Shor

Inti dari algoritma ini merupakan bagaimana cara menyelesaikan faktorisasi terhaadap bilanga interger atau bulat yang besar.

Algoritma Shor terdiri dari dua bagian:

  Penurunan yang bisa dilakukan pada komputer klasik, dari masalah anjak untuk masalah ketertiban - temuan.
  Sebuah algoritma kuantum untuk memecahkan masalah order-temuan

</content>
      <categories>
        
          <category> tugas kuliah </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Pertemuan 1 Mata Kuliah Pengantar Komputasi Modern</title>
      <url>/2018/04/09/pertemuan-1-Pengantar-Komputasi-Modern/</url>
      <content type="text">Teori Komputasi

Pengertian Teori Komputasi
Teori komputasi adalah cabang ilmu komputer teoritis, berkaitan dengan studi bagaimana persoalan(problem) dapat diselesaikan pada sebuah model dengan menggunakan algoritma. Model tersebut dinamakan model komputasi.

Teori Otomata
Teori Otomata adalah teori mengenai mesin-mesin abstrak, dan berkaitan erat dengan teori bahasa formal. ada beberapa hal yang berkaitan dengan Otomata, yaitu Grammar. Grammar adalah bentuk abstrak yang dapat diterima (accept) untuk membangkitkan suatu kalimat otomata berdasarkan suatu aturan tertentu.

Teori Komputabilitas

Teori komputabilitas bertujuan untuk memeriksa apakah persoalan komputasi dapat dipecahkan pada suatu model komputasi teoritis. Dengan kata lain, teori komputabilitas mengklasifikasikan persoalan sebagai dapat dipecahkan (solvable) atau persoalan yang tidak dapat dipecahkan (unsolvable).

Teori Kompleksitas
Teori kompleksitas bertujuan untuk mengkaji kebutuhan waktu dan ruang untuk memecahkan persoalan yang diselesaikan dengan pendekatan yang berbeda-beda.

Model komputasi

Finite State Automata(FSA) / Finite State Machine(FSM)
Finite State Machine dapat berupa suatu mesin yang tidak memiliki output. Finite State Machine yang tidak mengeluarkan output ini dikenal sebagai Finite State Automata (FSA).

Secara formal FSA dapat didefinisikan sebagai TUPLE-5 : (K, VT, M, S, Z)
Dimana :
K	: himpunan hingga stata,
VT 	: himpunan hingga simbol input (alfabet)
M 	: fungsi transisi, menggambarkan transisi stata AH akibat pembacaan symbol input. (Fungsi transisi ini biasanya diberikan dalam bentuk tabel.)
S  	: stata awal
Z  	: himpunan stata penerima

Ada dua jenis Finite State Automata :
• Deterministic Finite Automata : transisi stata AH akibat pembacaan sebuah simbol
bersifat tertentu. “Jika pada setiap state dari FSA tersebut apabila menerima input
sebuah simbol maka HANYA ada SATU NEXT STATE yang mungkin dituju.”
M(DFA) : K x VT x K

• Non Deterministik Finite Automata : transisi stata AH akibat pembacaan sebuah simbol
bersifat tak tentu. “Jika FSA tersebut menerima input simbol maka minimal ada satu
state yang akan berpindah ke LEBIH DARI SATU NEXT STATE yang mungkin dituju.”
M(AHN) : K x VT x 2K

Contoh Soal

Push Down Automata(PDA)
PDA adalah mesin otomata yang memiliki kendali masukan menggunakan teknik LIFO (Last In First Out), untuk menentukan apakah suatu output diterima atau tidak oleh mesin tsb. Dalam melakukan proses peneerimaan input, PDA menggunakan memory stack.
Mekanisme kerja memory stack adalah menyimpan input pertama pada alamat paling bawah, input berikutnya di simpan pada alamat di atasnya, dan input terakhir di simpan pada alamat paling atas. Perintah operasi yang digunakan untuk menyimpan input pada stack adalah “push”. Sedangkan perintah operasi untuk mengeluarkan input yang telah tersimpan adalah “pop”.

Sebuah PDA dinyatakan dengan 7 Tupel:
Q = himpunan state
Σ = himpunan simbol input
T = simbol stack
Δ = fungsi transisi
S = state awal
F = state akhir
Z = top of stack

Turing Machine

Mesin Turing adalah model komputasi teoretis yang ditemukan oleh Alan Turing, berfungsi sebagai model ideal untuk melakukan perhitungan matematis. Walaupun model ideal ini diperkenalkan sebelum komputer nyata dibangun, model ini tetap diterima kalangan ilmu komputer sebagai model komputer yang sesuai untuk menentukan apakah suatu fungsi dapat selesaikan oleh komputer atau tidak (menentukan computable function). Mesin Turing terkenal dengan ungkapan “ Apapun yang bisa dilakukan oleh Mesin Turing pasti bisa dilakukan oleh komputer.”



Implementasi

Bidang Fisika
Implementasi komputasi modern di bidang Fisika adalah Computational Physics yang mempelajari suatu gabungan antara Fisika, Komputer Sains dan Matematika Terapan untuk memberikan solusi pada “Kejadian dan masalah yang kompleks pada dunia nyata” baik dengan menggunakan simulasi juga penggunaan Algoritma yang tepat.
Banyak perangkat lunak ataupun bahasa yang digunakan, seperti : MatLab, Visual Basic, Fortran, Open Source Physics (OSP), Labview, Mathematica, dan lain sebagainya digunakan untuk pemahaman dan pencarian solusi numerik dari masalah-masalah pada Fisika komputasi.
Bidang Kimia
Implementasi komputasi modern di bidang Kimia adalah Computational Chemistry yaitu penggunaan ilmu komputer untuk membantu menyelesaikan masalah Kimia. Contohnya penggunaan super komputer untuk menghitung struktur dan sifat molekul. Istilah Kimia teori dapat didefinisikan sebagai deskripsi Matematika untuk Kimia, sedangkan Kimia komputasi biasanya digunakan ketika metode Matematika dikembangkan dengan cukup baik untuk dapat digunakan dalam program komputer.
Bidang Matematika
Menyelesaikan sebuah masalah yang berkaitan dengan perhitungan Matematis, namun dalam pengertian yang akan dibahas dalam pembahasan komputasi modern ini merupakan sebuah sistem yang akan menyelesaikan masalah Matematis menggunakan komputer dengan cara menyusun Algoritma yang dapat dimengerti oleh komputer.
Bidang Geografi
Komputasi dalam bidang Geografi biasanya di gunakan untuk peramalan cuaca, di Indonesia khususnya ada salah satu instansi Negara dengan nama BMKG (Badan Meteorologi Klimatologi dan Geofisika) yakni instansi negara yang meneliti mengamati tentang Metereologi, Klimatologi kualitas udara dan Geofisika
Bidang Geologi
Implementasi pada bidang ini untuk memetakan letak sumber daya dan kontur dari permukaan bumi yang terdapat hasil tambang.

Cloud Computing
Cloud Computing hadir dengan memudahkan akses data dari mana saja dan kapan saja, karena dengan memanfaatkan internet dan menggunakan perangkat fixed atau mobile device menggunakan internet cloud sebagai tempat penyimpanan data, aplikasi dan lainya

Grid Computing

Komputasi Grid sebenarnya merupakan sebuah aplikasi pengembangan dari jaringan komputer (network). Hanya saja, tidak seperti jaringan komputer konvensional yang berfokus pada komunikasi antar piranti (device), aplikasi pada grid computing dirancang untuk memanfaatkan sumber daya pada terminal dalam jaringannya.

Virtualisasi
Virtualisasi adalah sebuah teknologi, yang memungkinkan anda untuk membuat versi virtual dari sesuatu yang bersifat fisik, misalnya sistem operasi, storage data atau sumber daya jaringan. Proses tersebut dilakukan oleh sebuah software atau firmware bernama Hypervisor. Hypervisor inilah yang menjadi nyawanya virtualisasi, karena dialah layer yang “berpura – pura” menjadi sebuah infrastruktur untuk menjalankan beberapa virtual machine.

Istilah virtualisasi perangkat-keras mengacu kepada upaya menciptakan mesin virtual yang bekerja layaknya sebuah komputer lengkap dengan sistem operasi.

Para-virtualisasi: Perangkat keras tidak disimulasikan tetapi perangkat-lunak tamu berjalan dalam domainnya sendiri seolah-olah dalam sistem yang berbeda. Dalam hal ini perangkat-lunak tamu perlu disesuaikan untuk dapat berjalan.

Virtualisasi sebagian: Tidak semua aspek lingkungan disimulasikan tidak semua perangkat-lunak dapat langsung berjalan, beberapa perlu disesuaikan untuk dapat berjalan dalam lingkungan virtual ini.

Virtualisasi penuh: Hampir menyerupai mesin asli dan mampu menjalankan perangkat lunak tanpa perlu diubah.

Distributed Computation dalam Cloud Computing

Komputasi Terdistribusi merupakan salah satu tujuan dari Cloud Computing, karena menawarkan pengaksesan sumber daya secara parallel, para pengguna juga bisa memanfaatkannya secara bersamaan (tidak harus menunggu dalam antrian untuk mendapatkan pelayanan), terdiri dari banyak sistem sehingga jika salah satu sistem crash, sistem lain tidak akan terpengaruh, dapat menghemat biaya operasional karena tidak membutuhkan sumber daya (resourches).

Standar Teknologi Informasi pada Cloud Computing


SaaS (Software as a Service)
Software as a Service adalah layanan software yang digunakan melalui internet. Sebenarnya hal ini bukan merupakan hal yang asing dan sering kita gunakan (hanya mungkin kita belum tahu aja), contoh dari SaaS ini adalah google docs, facebook, aplikasi CRM berbayar, dan lain-lain. Pengguna hanya perlu menggunakan aplikasi tersebut tanpa harus mengerti bagaimana data disimpan, bagaimana aplikasi tersebut di maintenance, karena hal tersebut merupakan service yang disediakan penyedia jasa. Pembayaran dari penggunaan aplikasi-aplikasi ini pun hanya per pemakaiannya (terkadang ada yang tak berbayar tetapi ada fitur-fitur tertentu yang bisa didapatkan ketika pengguna membayar fitur-fitur tersebut, yah semacam nyewa parabola gitu lah, bayar berdasar channel yang diinginkan).

PaaS (Platform as a Service)
Platform as a Service adalah penyediaan platform bagi developer yang disediakan melalui internet. Hal ini dibutuhkan ketika aplikasi yang disediakan melalui SaaS tidak sesuai dengan kebutuhan proses bisnis yang terdapat pada perusahaan. PaaS memungkinkan kita untuk membangun aplikasi, mengupload aplikasi, melakukan testing aplikasi, ataupun mengatur konfigurasi yang dibutuhkan dalam proses pengembangan aplikasi.

IaaS (Infrastructure as a Service)
Infrastructure as a Service adalah penyediaan infrastruktur yang disediakan melalui internet dan dibayarkan berdasarkan pemakaian. Hal ini terjadi apabila developer membutuhkan sebuah infrastruktur dimana dia dapat melakukan setting untuk jalannya sebuah aplikasi. IaaS memberikan kendali penuh bagi pengguna layanan untuk menyewa infrastruktur IT (storage, RAM, prosesor dll) secara virtual tanpa sistem operasi, yang tentunya pemilihan sistem operasi tersebut dipilih berdasarkan keinginan pengguna.  Apabila SaaS dan PaaS kurang terasa manfaatnya bagi perusahaan, IaaS ini sangat menguntungkan bagi perusahaan kecil yang membutuhkan sebuah infrastruktur IT tanpa harus membeli perangkat yang dibutuhkan tersebut.
</content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Rangkuman Sistem Multimedia</title>
      <url>/tugas%20kuliah/2018/03/21/rangkuman-sistem-multimedia/</url>
      <content type="text">Multimedia  : Adalah beberapa media yang berbeda untuk menggabungkan dan menyampaikan informasi dalam bentuk Text , Audio , Grafik , Animasi dan Video atau bisa juga di katakan kombinasi antara tiga elemen yaitu suara, gambar dan text.

Sistem  : Adalah kumpulan dari elemen – elemen yang berinteraksi untuk mencapai suatu tujuan tertentu.

Sistem Multimedia : Adalah beberapa sistem yang mendukung lebih dari satu macam   media.
Text

jenis text terbagi dalam 3 kategori

Plain text
Plain text adalah teks yang dikode dalam format ASCII

Contoh :



Hyper Text
Hypert Text adalah teks yang memiliki fasilitas linking dan betujuan untuk menyambungkan/berhubungan dengan dokumen lain/teks sebelumnya yang telah diberi atau memiliki format pada sisi penulisannya. Hypert Text disebut juga sebagai link penghubung.
 Hypertext terbagi menjadi dua,yaitu  :


  
    HTML (Hypertext Markup Language) yang berfungsi untuk mengontrol tampilan web
  
  
    XML (Extensible Markup Language) yang berfungsi untuk menjadikan dokumen lebih simple dan lebih cepat.
  


Rich text
Rich Text Format adalah teks yang sudah diformatting dan sudah di desain sedemikian rupa sehingga pada teks ini kita dapat memberikan efek pada teks dengan di Bold, Italic, Underline dan diberi warna.


Image
Image atau citra adalah gambar pada bidang dua dimensi
Sebuah titik terkecil dalam sebuah gambar grafis yang dihitung per inci disebut dengan pixel.


Video
Video
Merupakan rangkaian gambar yang ditampilkan secara sekuensial

Representasi dan Kompresi Data

Kompresi Data merupakan cara untuk memperkeil kebutuhan penyimpanan data

Kompresi terbagi 2 jenis yaitu Lossy dan Loseless


  
    Lossy : teknik kompresi dengan menghilangkan beberapa informasi penting
  
  
    Loseless : teknik kompresi dengan tidak menghilangkan beberapa informasi
  


Representasi dan Kompresi pada Data Teks

Run Length Encoding
Suatu teknik kompresi dengan menghasilkan output Loseless

Contoh :

Data: ABCCCCCCCCDEFGGGG = 17 karakter

dapat menggunakan tanda ! untuk mengurangi panjang nya data sehingga menjadi seperti ini

Data: ABCCCCCCCCDEFGGGG = 17 karakter

Huffman Coding
Huffman merupakan teknik dengan banyak nya 1 huruf kemudian dibagi banyak nya huruf maka dilakukan Kompresi

Contoh :

MAMA SAYA
A = 4 -&amp;gt; 4/8 = 0.5
M = 2 -&amp;gt; 2/8 = 0.25
S = 1 -&amp;gt; 1/8 = 0.125
Y = 1 -&amp;gt; 1/8 = 0.125
Total = 8 karakter

kemudian dibuat pohon Huffman nya maka menjadi seperti ini


Representasi dan Kompresi pada Data Suara

Kompresi pada Audio yaitu dengan memotong jarak amplitudo paling maksimum dan minimum yang dianggap noise

Contoh Lossy format :Vorbis, MP3

Contoh Loseless format : FLAC

Jaringan Multimedia
Penggunaan komputer untuk menampilkan media dengan interaksi dan komunikasi

Streaming Multimedia

Merupakan multimedia yang secara terus menerus diterima dan ditampilkan oleh user

Voice Over Internet protocol

teknologi yang memungkinkan komunikasi suara menggunkana jaringan berbasis IP

Session Internet Protocol
SIP merupakan sebuah protocol standart multimedia dimana merupakan produk dari Internet Engineering Task Force (IETF) dan telah digunakan menjadi suatu standart penggunaan VoIP

Real Time Transport

Real Time Transport Protocol  (RTP) didefinisikan sebagai standarisasi paket untukmengirimkan audio dan video pada jaringan IP.

Distribusi multimedia

B. Broadcasting penyiaran multimedia baik berupa video maupun suara yang disiarkan kepada penonton melalui media elektronik. Ex: Live instagram


Cara kerja tv:
    • Kamera merekam sebuah objek yang dengan sistem prism dibagi menjadi tiga warna
    • CCD mengubahnya menjadi sebuah elektronik signal yang disebut video signal
    • Tranmisi merubahnya menjadi signal televisi yang disiarkan melalui antenna dengan gelombang elektromagnetik
    • Anttena rumah akan menerima signal televisi
    • Tunner memisahkan video signal dengan audio signak
    • Video signal dibagi menjadi tiga signal
    • Ketiga signal akan menampilkan gambar

Cara kerja live broadcasting:
bekerja di saat yang bersamaan secara langsung, dimana audio mengirim datanya ke sound card dan dienkripsi oleh encoder yang akan langsung diupload ke streaming server oleh streamer.
EX:

C. Internet Radio Yaitu: audio digital yang ditransmisikan melalui internet. Cara kerja internet radio:
1. Audio pada sebuah sound card diencoding pada komputer yang digunakan untuk broadcasting
2. Sistem encode menterjemahkan audio ke streaming format dan mengkompresnya untuk bisa dikirimkan via internet.
3. Audio yang telah dikompres dikirim ke server
4. Server mengirimkan data audio melalui internet ke komputer pendengar melalui sebuah plug-in atau software.
5. Plug-in akan menterjemhkan data audio dari server ke suara yang bisa didengar pendengar   EX: Prambors









D. Video on Demand (VoD) sistem televisi interaktif yang memfasilitasi untuk memilih sendiri program televisi atau video yang ingin ditonton.


Augmented Reality

sebuah konsep yang memadukan dunia maya(virtual) dan dunia nyata dengan cara menanamkan sebuah object di dalam proses pembuatannya.

Jenis - jenis

  
    Memakai Marker (Marker Based Tracking), yaitu terdapat proses pemakaian marker didalamnya untuk memunculkan objek 2D atau 3D.
  
  
    Tanpa Marker (Markerless), yaitu tidak terdapat pemakaian marker didalamnya tetapi menggunakan teknik yang mempunyai ruang lingkup lebih luas daripada metode Marker Based Tracking.
  


Digital Culture

suatu perkembangan yang menjadikan budaya di era digital contoh nya seperti mengakses informasi dari internet, serta mengirimkan email dan download upload

contoh : E-commerce, E-book dll
</content>
      <categories>
        
          <category> tugas kuliah </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Sentiment Analysis with Python 3</title>
      <url>/tutorial/2018/03/19/sentiment-analysis/</url>
      <content type="text">Team


  Abdul Ghoni Abbasi (5C414919)
  Aldi Ginanjar (50414741)
  M. Fadlan Prayoga (56414918)
  Widya Maylani (5C414218)


Scraping

  Web Scraping adalah pengambilan sebuah dokumen semi-struktur dari internet, umumnya berupa halaman-halaman web dalam bahasa markup seperti HTML atau XHTML, dan menganalisis untuk diambil data tertentu dari halaman tersebut




import requests

graph_api_version = 'v2.9'
# paste your access token below
access_token = 'EAAanvSwEfswBAG4xDMDJuJqmsPb179nvHy0XPMR7BcgPejGKBhaa7Iy0EaQu2W5PCOA92BcgiZA9nXJCJrFZBzKksVGwMCQHX7oq7lAXsn4YZBObZAZCI9kKa04m0eMsOpNoeZAwveKaZBu2cKQDUfycIM8zjbor0tbSplAABUlwQZDZD'

user_id = '164305410295882'


post_id = '1727321057327635'


url = 'https://graph.facebook.com/{}/{}_{}/comments'.format(graph_api_version, user_id, post_id)

comments = []

r = requests.get(url, params={'access_token': access_token})
while True:
    data = r.json()
    if 'error' in data:
        raise Exception(data['error']['message'])
    for comment in data['data']:
        text = comment['message'].replace('\n', ' ')
        comments.append(text)
    print('got {} comments'.format(len(data['data'])))
    if 'paging' in data and 'next' in data['paging']:
        r = requests.get(data['paging']['next'])
    else:
        break

#menyimpan komentar ke dalam suatu file
with open('comments.txt', 'w', encoding='utf-8') as f:
    for comment in comments:
        f.write(comment + '\n')


import library requests agar mendapatkan akses token dari facebook, kemudian memasukkan access token yang terdapat pada facebook. Berikutnya untuk mengambil semua data komentar pada suatu post facebook yang dibutuhkan adalah id dari user facebook dan id dari post  yang ditentukan dalam variabel url nya. Setelah itu bisa di ketahui konsep scraping untuk mengambil semua komentar di dalam suatu post tersebut membuat array dengan nama comments and menggunakan library requests untuk mendapatkan akses token, untuk dibuat scraping atau data komentar dari suatu post dibuat kondisi terdapat error dalam data JSON tersebut maka ditampilkan pesan error, jika tidak maka dimuat isi array dengan banyak nya komentar menggunakan perintah

for comment in data['data']:
  text = comment['message'].replace('\n', ' ')
  comments.append(text)

Jika sudah simpan file python dengan nama scraping.py lalu run program yang sudah dibuat dengan perintah python3 scraping.py maka akan ditampilkan output


Kemudian untuk data comment yang sudah di extract disimpan dalam file bernama comments.txt dan output yang dhasilkan dari script python diatas berupa:



Sentiment Analysis

Sebelum melakukan sentimen analisis, import library seperti NLTK, pandas

import nltk
import pandas as pd
import string


Library yang digunakan yaitu vader lexicon untuk pemanggilan fungsi SentimentIntensityAnalyzer()
from nltk.sentiment.vader import SentimentIntensityAnalyzer
sid = SentimentIntensityAnalyzer()

Print Positive, Negative and Neutral

summary = {&quot;positive&quot;:0,&quot;neutral&quot;:0,&quot;negative&quot;:0}
for x in messages:
    ss = sid.polarity_scores(x)
    if ss[&quot;compound&quot;] == 0.0:
        summary[&quot;neutral&quot;] +=1
    elif ss[&quot;compound&quot;] &amp;gt; 0.0:
        summary[&quot;positive&quot;] +=1
    else:
        summary[&quot;negative&quot;] +=1
print(summary)


untuk penentuan suatu komentar termasuk komentar positif dibuat kondisi jika nilai variabel ss yang merupakan perhitungan pada library SentimentIntensityAnalyzer() sama dengan 0 maa akan masuk ke dalam indeks “neutral” akan bertambah 1, untuk nilai lebih dari sama dengan maka akan masuk ke dalam indeks “positive” dan untuk nilai komentar yang negatif jika nilai nya kurang dari 0 maka indeks array “negative” akan bertambah. Untuk mencetak perolehan angka sentimen gunakan perintah print(summary)


{'positive': 57, 'neutral': 81, 'negative': 55}


Result from Pie Chart

import matplotlib.pyplot as plt
pie_plot = pd.Series(summary,name='')
pie_plot.plot.pie(fontsize=11,figsize=(6,6),autopct='%.2f');


Kemudian untuk memvisualisasikan data sentimen nya,gunakan library matplotlib dan dipanggil perintah untuk menyajikan data chart dengan jenis pie sehingga data yang ditampilkan dengan menampilkan dictionary summary dan menampilkan angka persentasi 2 angka dibelakang koma dengan perintah autopct=%2.f maka outputnya adalah

</content>
      <categories>
        
          <category> tutorial </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
